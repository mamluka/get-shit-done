---
phase: 07-markdown-to-notion-conversion
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/notion/block-utils.js
  - lib/notion/chunker.js
  - test/notion/block-utils.test.js
  - test/notion/chunker.test.js
autonomous: true

must_haves:
  truths:
    - "Deeply nested blocks (3+ levels) flatten to 2 levels with └ indent markers on demoted items"
    - "Block arrays exceeding 90 blocks split at heading boundaries into section-aware chunks"
    - "Single sections exceeding ~100 blocks force-split at logical points (list items, table rows)"
    - "Chunks never exceed 100 blocks (Notion API hard limit)"
    - "Details/summary blockquotes post-process to toggle block structure"
  artifacts:
    - path: "lib/notion/block-utils.js"
      provides: "Notion block post-processing utilities (nesting flattener, toggle converter)"
      exports: ["flattenDeepNesting", "convertQuotesToToggles"]
    - path: "lib/notion/chunker.js"
      provides: "Section-aware block chunking for Notion API limits"
      exports: ["chunkBlocks"]
    - path: "test/notion/block-utils.test.js"
      provides: "Test coverage for block utilities"
      contains: "flattenDeepNesting"
    - path: "test/notion/chunker.test.js"
      provides: "Test coverage for chunker"
      contains: "chunkBlocks"
  key_links:
    - from: "lib/notion/block-utils.js"
      to: "Notion API block structure"
      via: "Transforms Martian output blocks to comply with Notion nesting limits"
      pattern: "children.*rich_text"
    - from: "lib/notion/chunker.js"
      to: "Notion API 100-block limit"
      via: "Splits block arrays for pages.create + blocks.children.append pattern"
      pattern: "heading_[123]"
---

<objective>
Create the block post-processing utilities and section-aware chunker for the Notion conversion pipeline.

Purpose: After Martian converts markdown to Notion blocks, these modules handle two critical Notion API constraints: (1) nesting depth limited to 2 levels per request, and (2) maximum 100 blocks per request. The block utilities flatten deep nesting and convert details/summary blockquotes to toggle blocks. The chunker splits large documents at heading boundaries for API compliance.

Output: Two tested utility modules (block-utils.js, chunker.js) ready for the converter orchestrator in Plan 03.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-markdown-to-notion-conversion/07-RESEARCH.md
@.planning/phases/07-markdown-to-notion-conversion/07-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD block-utils.js — nesting flattener and toggle block converter</name>
  <files>lib/notion/block-utils.js, test/notion/block-utils.test.js</files>
  <action>
    Create lib/notion/block-utils.js exporting two functions for post-processing Martian's Notion block output.

    **`flattenDeepNesting(blocks, maxDepth = 2)`**
    Per user decision: deep nesting (3+ levels) flattens to 2 levels — third-level items become second-level with `└` prefix indent markers.

    Walk the block tree recursively. Notion blocks store children in `block[block.type].children`. When a block is at `maxDepth` and has children:
    1. Remove children from the parent block
    2. Prepend `└ ` to each child's rich_text content (first element of rich_text array)
    3. Insert flattened children as siblings after the parent

    Block types with children: `bulleted_list_item`, `numbered_list_item`, `to_do`, `toggle`, `callout`, `quote`.

    Edge cases:
    - Blocks without rich_text (e.g., divider, table) skip indent marker
    - 4+ levels: recursively flatten until maxDepth is respected
    - Empty children arrays: handle gracefully (no-op)
    - Mixed block types at deep levels: all get flattened

    **`convertQuotesToToggles(blocks)`**
    Per user decision: `<details>/<summary>` maps to toggle blocks. The preprocessor (Plan 01) converts these to blockquotes with bold summary. This post-processor detects the pattern and converts to Notion toggle blocks.

    Detection pattern in Martian's blockquote output: A `quote` block whose first rich_text starts with bold annotation text, followed by content children.

    Convert to:
    ```javascript
    {
      type: 'toggle',
      toggle: {
        rich_text: [/* summary text from bold heading */],
        color: 'default',
        children: [/* remaining blockquote content */]
      }
    }
    ```

    Note: Only convert blockquotes that match the details/summary pattern (first child is bold text). Leave regular blockquotes unchanged.

    **TDD cycle:**
    RED: Write tests covering:
    1. 2-level nesting passes through unchanged
    2. 3-level nesting flattens third level to second with └ marker
    3. 4-level nesting recursively flattens to 2 levels
    4. Mixed block types (bulleted + numbered + to_do) all flatten correctly
    5. Blocks without children pass through unchanged
    6. Empty children arrays handled gracefully
    7. └ marker prepended to existing rich_text content
    8. Blockquote with bold first child converts to toggle block
    9. Regular blockquote (no bold first child) stays as blockquote
    10. Toggle children preserve their content and structure

    GREEN: Implement both functions to pass tests.
    REFACTOR: Clean up if needed.

    Use Node.js built-in test runner (`node --test`). Build test block structures using literal Notion block objects (not Martian — keep tests independent of Martian version).
  </action>
  <verify>
    Run `node --test test/notion/block-utils.test.js` — all tests pass.
    Manually verify: Create a 3-level nested block structure and confirm flattenDeepNesting produces 2-level output with └ markers.
  </verify>
  <done>
    flattenDeepNesting() correctly flattens 3+ level nesting to 2 levels with └ indent markers. convertQuotesToToggles() converts details/summary-pattern blockquotes to toggle blocks while leaving regular blockquotes unchanged. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD chunker.js — section-aware block batching for Notion API limits</name>
  <files>lib/notion/chunker.js, test/notion/chunker.test.js</files>
  <action>
    Create lib/notion/chunker.js exporting a single `chunkBlocks(blocks, maxPerChunk = 90)` function.

    Per user decision: section-aware batching splits at heading boundaries so each API request contains complete sections. If a single section exceeds ~100 blocks, force-split within the section at logical points.

    **Core algorithm:**
    1. Walk blocks array, tracking current chunk size
    2. When encountering a heading block (heading_1, heading_2, heading_3) AND current chunk is at or above `maxPerChunk`, start a new chunk with the heading as its first block
    3. If no heading is found and chunk exceeds `maxPerChunk`, force-split at logical boundaries:
       - For consecutive list items (bulleted_list_item, numbered_list_item, to_do): split between items
       - For table blocks: split at table boundaries (never mid-table)
       - For other blocks: split at any block boundary
    4. Return array of arrays: `Block[][]`

    **Force-split logic for oversized sections:**
    If accumulating blocks reaches 100 (hard limit) without encountering a heading:
    - Scan backward from position 100 for a list item boundary or paragraph boundary
    - Split there to avoid mid-content breaks
    - Never split inside a table (table_row must stay with its table parent)

    **Table handling:**
    Tables in Notion are `table` blocks with `table_row` children. When chunking, count the table as 1 + N blocks (1 table + N rows). Never split table rows from their table parent. If a single table exceeds maxPerChunk, it goes in its own chunk (allowed to exceed soft limit since Notion supports up to 100 rows per table block).

    Edge cases:
    - Document with < maxPerChunk blocks: returns single chunk
    - Empty blocks array: returns empty array
    - All headings: each heading starts new chunk (may produce small chunks)
    - Single block exceeding limits: goes in its own chunk
    - Heading as very last block: goes into current chunk (not new chunk alone)

    **TDD cycle:**
    RED: Write tests covering:
    1. Small document (< 90 blocks) returns single chunk
    2. Large document splits at heading boundaries
    3. Section exceeding 100 blocks force-splits at list item boundary
    4. Table blocks stay together (never split table from its rows)
    5. Empty input returns empty array
    6. No headings in document: force-splits at logical points
    7. All chunks respect 100-block hard maximum (except oversized tables)
    8. Heading at end of document doesn't create empty trailing chunk
    9. Mixed content (headings, paragraphs, lists, tables, code) chunks correctly
    10. Custom maxPerChunk parameter works (e.g., maxPerChunk=10 for testing)

    GREEN: Implement to pass all tests.
    REFACTOR: Clean up if needed.

    Use Node.js built-in test runner (`node --test`). Build test blocks as arrays of simple block objects — only `type` field needed for chunking logic, plus `children` for table blocks.
  </action>
  <verify>
    Run `node --test test/notion/chunker.test.js` — all tests pass.
    Manually verify: Create array of 150 blocks with headings at positions 50 and 120, confirm output has 2 chunks splitting at heading boundaries.
  </verify>
  <done>
    chunkBlocks() splits at heading boundaries when approaching 90-block soft limit. Force-splits oversized sections at logical points (list item boundaries). Tables never split from their rows. All chunks respect 100-block hard limit. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `node --test test/notion/block-utils.test.js` — all tests green
2. `node --test test/notion/chunker.test.js` — all tests green
3. `node -e "require('./lib/notion/block-utils.js')"` — loads without error
4. `node -e "require('./lib/notion/chunker.js')"` — loads without error
5. No external dependencies added (operates on plain JavaScript objects)
</verification>

<success_criteria>
- block-utils.js flattens 3+ level nesting to 2 levels with └ markers per user decision
- block-utils.js converts details/summary blockquotes to toggle blocks
- chunker.js splits at heading boundaries with section awareness
- chunker.js force-splits oversized sections at logical points
- Tables never separated from their rows during chunking
- All TDD tests pass with edge case coverage
- Zero external dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/07-markdown-to-notion-conversion/07-02-SUMMARY.md`
</output>

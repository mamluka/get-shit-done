---
phase: 08-page-hierarchy-incremental-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/notion/hierarchy.js
  - lib/notion/change-detector.js
  - lib/notion/page-manager.js
autonomous: true

must_haves:
  truths:
    - "Folder hierarchy builder produces parent/child tree matching .planning/ directory structure"
    - "SHA-256 hash comparison detects changed files and skips unchanged ones"
    - "Page manager can create new pages with parent relationships and update existing pages by replacing content"
    - "Parent page ID is validated before child page creation"
    - "Stale page IDs (deleted in Notion) are detected and handled gracefully"
  artifacts:
    - path: "lib/notion/hierarchy.js"
      provides: "Folder-to-page hierarchy mapping"
      exports: ["buildHierarchy"]
    - path: "lib/notion/change-detector.js"
      provides: "SHA-256 file hashing and change detection"
      exports: ["hashFile", "needsSync"]
    - path: "lib/notion/page-manager.js"
      provides: "Notion page CRUD operations"
      exports: ["createPage", "updatePage", "validatePageExists"]
  key_links:
    - from: "lib/notion/hierarchy.js"
      to: "fs.readdirSync"
      via: "directory traversal"
      pattern: "readdirSync.*phases"
    - from: "lib/notion/change-detector.js"
      to: "crypto.createHash"
      via: "streaming SHA-256"
      pattern: "createHash.*sha256"
    - from: "lib/notion/page-manager.js"
      to: "@notionhq/client"
      via: "Notion SDK page operations"
      pattern: "notion\\.pages\\.(create|update)"
---

<objective>
Build the three foundation modules for Phase 8 sync: hierarchy builder (maps .planning/ folder structure to parent/child page relationships), change detector (SHA-256 file hashing for incremental sync), and page manager (Notion API create/update/replace page operations).

Purpose: These modules provide the building blocks that the sync orchestrator (Plan 02) will compose. Each module has a single responsibility and clean API for testability and reuse.

Output: Three new modules in lib/notion/ — hierarchy.js, change-detector.js, page-manager.js
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-page-hierarchy-incremental-sync/08-RESEARCH.md
@.planning/phases/06-foundation-sdk-setup/06-01-SUMMARY.md
@.planning/phases/07-markdown-to-notion-conversion/07-03-SUMMARY.md
@lib/notion/sync-state.js
@lib/notion/client.js
@lib/notion/converter.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hierarchy builder and change detector modules</name>
  <files>lib/notion/hierarchy.js, lib/notion/change-detector.js</files>
  <action>
**hierarchy.js** — Create `buildHierarchy(planningDir)` function that:
1. Scans `planningDir` (typically `.planning/`) and returns a tree structure representing page hierarchy
2. Root node = PROJECT.md (becomes the parent page in Notion)
3. Priority children at root level: ROADMAP.md, REQUIREMENTS.md, STATE.md (in that order, only if they exist)
4. Phase folders (`.planning/phases/XX-name/`) become intermediate grouping nodes. Each phase folder gets a "virtual" page (titled after the folder name, e.g., "Phase 08 - Page Hierarchy & Incremental Sync") that serves as parent for its child .md files
5. Phase folder children: all .md files inside, sorted alphabetically
6. Any other .md files in .planning/ root that aren't PROJECT.md, ROADMAP.md, REQUIREMENTS.md, or STATE.md get added after phases, sorted alphabetically
7. Skip non-.md files, hidden directories (starting with `.` or `_`), and `node_modules`
8. Return structure:
```javascript
{
  root: { file: '/abs/path/PROJECT.md', title: 'PROJECT', children: [...] },
  // Each child is either:
  // { file: '/abs/path/ROADMAP.md', title: 'ROADMAP', children: [] }  (leaf file)
  // { folder: '/abs/path/phases/08-name', title: 'Phase 08 - Page Hierarchy...', children: [...] }  (phase grouping)
}
```
9. Title extraction: For files, use filename without .md extension. For phase folders, transform `08-page-hierarchy-incremental-sync` to `Phase 08 - Page Hierarchy Incremental Sync` (capitalize first letter of each word, replace hyphens with spaces, prefix with "Phase").
10. Use synchronous fs operations (readFileSync, readdirSync) to match existing codebase patterns.
11. Export: `buildHierarchy`

**change-detector.js** — Create two functions:
1. `hashFile(filePath)` — Returns Promise resolving to hex SHA-256 hash of file contents using streaming (crypto.createReadStream pattern from research). Use Node.js built-in `crypto` module.
2. `needsSync(filePath, syncState, projectSlug)` — Compares current file hash against stored hash in syncState.projects[projectSlug].doc_pages[filePath].hash. Returns object:
   - `{ needsSync: true, reason: 'unmapped', hash: currentHash }` — No mapping exists
   - `{ needsSync: true, reason: 'no_hash', hash: currentHash }` — Mapping exists but no hash stored (first sync after upgrade)
   - `{ needsSync: true, reason: 'changed', hash: currentHash }` — Hash differs
   - `{ needsSync: false, reason: 'unchanged', hash: currentHash }` — Hash matches
   Note: `needsSync` checks `syncState.projects[projectSlug]?.doc_pages?.[filePath]` for both `page_id` and `hash` fields. The doc_pages values will be objects (not just page_id strings) after this phase: `{ page_id: string, hash: string, syncedAt: string }`.
3. Export: `hashFile`, `needsSync`
  </action>
  <verify>
Run `node -e "const h = require('./lib/notion/hierarchy.js'); const tree = h.buildHierarchy('.planning'); console.log(JSON.stringify(tree, null, 2))"` — should show PROJECT.md as root with ROADMAP.md, STATE.md, etc. as children, phase folders with nested .md files.

Run `node -e "const cd = require('./lib/notion/change-detector.js'); cd.hashFile('.planning/PROJECT.md').then(h => console.log('hash:', h))"` — should print a 64-char hex SHA-256 hash.

Run `node -e "const cd = require('./lib/notion/change-detector.js'); cd.needsSync('.planning/PROJECT.md', { projects: {} }, 'test').then(r => console.log(r))"` — should return `{ needsSync: true, reason: 'unmapped', hash: '...' }`.
  </verify>
  <done>
hierarchy.js exports buildHierarchy that returns a tree matching .planning/ folder structure with PROJECT.md as root, priority files as direct children, phase folders as intermediate grouping nodes, and all .md files as leaves. change-detector.js exports hashFile (streaming SHA-256) and needsSync (compares current hash vs stored) with four possible outcomes (unmapped, no_hash, changed, unchanged).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create page manager module for Notion page CRUD</name>
  <files>lib/notion/page-manager.js</files>
  <action>
Create lib/notion/page-manager.js with three exported functions:

1. **`validatePageExists(notion, pageId)`** — Async function that checks if a Notion page exists and is accessible.
   - Calls `notion.pages.retrieve({ page_id: pageId })`
   - Returns `{ exists: true, page: response }` on success
   - Returns `{ exists: false, error: 'not_found' }` if page was deleted (catch `object_not_found` error code)
   - Returns `{ exists: false, error: 'unauthorized' }` if page not shared with integration
   - Throws on network/unexpected errors (let caller handle)

2. **`createPage(notion, { parentPageId, title, blocks })`** — Async function that creates a new Notion page with parent relationship.
   - Calls `notion.pages.create()` with `parent: { page_id: parentPageId }` and title property
   - First 100 blocks go in `children` parameter of create call (Notion API limit)
   - If blocks.length > 100, append remaining blocks in batches of 100 using `notion.blocks.children.append()`
   - Returns the created page ID (string)
   - Before creating, validate parent exists using `validatePageExists`. If parent not found, throw descriptive error: `Parent page ${parentPageId} not found. Cannot create child page "${title}".`
   - Handle empty blocks array (creates page with title only, no children)

3. **`updatePage(notion, { pageId, title, blocks })`** — Async function that replaces all content of an existing Notion page.
   - Step 1: Update page title via `notion.pages.update()` with new title property
   - Step 2: Delete existing content — list all child blocks via `notion.blocks.children.list()` (paginate with page_size: 100 and `has_more`/`start_cursor`), then archive each block via `notion.blocks.update({ block_id, archived: true })`
   - Step 3: Append new blocks in batches of 100 via `notion.blocks.children.append()`
   - Returns the page ID (string)
   - If page not found (404), throw descriptive error: `Page ${pageId} not found. It may have been deleted in Notion.`

**Important implementation details:**
- Use `const { isNotionClientError } = require('@notionhq/client')` for type-safe error detection (same pattern as client.js)
- Block deletion must handle pagination — keep listing blocks until `has_more` is false
- For block append batches, process sequentially (not in parallel) to respect rate limits
- All functions accept `notion` (Client instance) as first parameter — do not create client internally
- JSDoc all functions with @param and @returns
- Follow existing code style: CommonJS (require/module.exports), no semicolons only if existing files omit them (they use semicolons — keep semicolons)
  </action>
  <verify>
Run `node -e "const pm = require('./lib/notion/page-manager.js'); console.log(Object.keys(pm))"` — should output `['validatePageExists', 'createPage', 'updatePage']`.

Verify the module loads without errors and all three functions are exported.

Run `node -e "const pm = require('./lib/notion/page-manager.js'); console.log(typeof pm.createPage, typeof pm.updatePage, typeof pm.validatePageExists)"` — should print `function function function`.
  </verify>
  <done>
page-manager.js exports three functions: validatePageExists (checks page accessibility, handles 404/unauthorized), createPage (creates with parent hierarchy, handles >100 block batching), and updatePage (replaces content via delete-all-append-new pattern with pagination). All functions accept Notion client as first parameter and use type-safe error handling consistent with existing client.js patterns.
  </done>
</task>

</tasks>

<verification>
All three modules load without errors:
```bash
node -e "require('./lib/notion/hierarchy.js'); require('./lib/notion/change-detector.js'); require('./lib/notion/page-manager.js'); console.log('All modules loaded')"
```

Hierarchy builder produces correct tree for current .planning/ directory:
```bash
node -e "const h = require('./lib/notion/hierarchy.js'); const t = h.buildHierarchy('.planning'); console.log('Root:', t.root.title, '| Children:', t.root.children.length)"
```

Change detector produces consistent hashes:
```bash
node -e "const cd = require('./lib/notion/change-detector.js'); Promise.all([cd.hashFile('.planning/PROJECT.md'), cd.hashFile('.planning/PROJECT.md')]).then(([a,b]) => console.log('Consistent:', a === b))"
```
</verification>

<success_criteria>
- Three new modules exist in lib/notion/: hierarchy.js, change-detector.js, page-manager.js
- buildHierarchy('.planning/') returns tree with PROJECT.md as root and correct children
- hashFile returns consistent 64-char hex SHA-256 hashes
- needsSync correctly identifies unmapped, no_hash, changed, and unchanged files
- createPage validates parent before creating child page
- updatePage replaces all content (delete existing + append new) with pagination
- All modules follow existing codebase patterns (CommonJS, JSDoc, synchronous where possible)
</success_criteria>

<output>
After completion, create `.planning/phases/08-page-hierarchy-incremental-sync/08-01-SUMMARY.md`
</output>

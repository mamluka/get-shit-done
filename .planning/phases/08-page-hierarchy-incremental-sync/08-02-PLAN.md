---
phase: 08-page-hierarchy-incremental-sync
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - lib/notion/sync-orchestrator.js
  - lib/notion/sync-state.js
  - bin/notion-sync.js
autonomous: true

must_haves:
  truths:
    - "User can run 'node bin/notion-sync.js sync' to push all .planning/ markdown to Notion"
    - "Sync creates new pages for unmapped files with correct parent/child hierarchy"
    - "Sync updates existing pages for previously synced files without creating duplicates"
    - "Hash-based change detection skips unchanged files to minimize API calls"
    - "notion-sync.json persists file-to-page-ID mappings with hashes across sync runs"
    - "CLI displays sync progress with per-file status indicators (creating/updating/skipped/error)"
  artifacts:
    - path: "lib/notion/sync-orchestrator.js"
      provides: "Main sync coordination logic"
      exports: ["syncProject"]
    - path: "lib/notion/sync-state.js"
      provides: "Extended sync state with hash and syncedAt tracking"
      exports: ["initSyncState", "loadSyncState", "saveSyncState", "getProjectState", "setProjectState", "getPageId", "setPageId"]
    - path: "bin/notion-sync.js"
      provides: "CLI sync subcommand with progress output"
  key_links:
    - from: "lib/notion/sync-orchestrator.js"
      to: "lib/notion/hierarchy.js"
      via: "buildHierarchy call"
      pattern: "require.*hierarchy.*buildHierarchy"
    - from: "lib/notion/sync-orchestrator.js"
      to: "lib/notion/change-detector.js"
      via: "needsSync call per file"
      pattern: "require.*change-detector.*needsSync"
    - from: "lib/notion/sync-orchestrator.js"
      to: "lib/notion/page-manager.js"
      via: "createPage/updatePage calls"
      pattern: "require.*page-manager.*(createPage|updatePage)"
    - from: "lib/notion/sync-orchestrator.js"
      to: "lib/notion/converter.js"
      via: "convertFile for markdown-to-blocks"
      pattern: "require.*converter.*convertFile"
    - from: "lib/notion/sync-orchestrator.js"
      to: "lib/notion/sync-state.js"
      via: "atomic state persistence after each file"
      pattern: "saveSyncState"
    - from: "bin/notion-sync.js"
      to: "lib/notion/sync-orchestrator.js"
      via: "syncProject call from CLI handler"
      pattern: "require.*sync-orchestrator.*syncProject"
---

<objective>
Build the sync orchestrator that coordinates hierarchy building, change detection, page creation/updates, and state persistence into a single `syncProject()` function. Wire it into the CLI as a `sync` subcommand with real-time progress output showing per-file status indicators.

Purpose: This is the user-facing deliverable for Phase 8 — the complete sync pipeline from `.planning/` markdown files to Notion pages, with incremental updates and duplicate prevention.

Output: lib/notion/sync-orchestrator.js (main sync logic), updated sync-state.js (extended doc_pages schema), updated bin/notion-sync.js (sync subcommand with progress)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-page-hierarchy-incremental-sync/08-RESEARCH.md
@.planning/phases/08-page-hierarchy-incremental-sync/08-01-SUMMARY.md
@lib/notion/hierarchy.js
@lib/notion/change-detector.js
@lib/notion/page-manager.js
@lib/notion/sync-state.js
@lib/notion/client.js
@lib/notion/converter.js
@bin/notion-sync.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync orchestrator and extend sync-state schema</name>
  <files>lib/notion/sync-orchestrator.js, lib/notion/sync-state.js</files>
  <action>
**sync-orchestrator.js** — Create the main sync coordination module with one primary export:

`syncProject(notion, options)` — Async function that orchestrates the full sync pipeline.

**Parameters:**
- `notion` — Notion Client instance (from client.js)
- `options.cwd` — Working directory (project root)
- `options.projectSlug` — Project slug for sync-state tracking (default: 'default')
- `options.parentPageId` — Notion page ID where the project root page will be created as a child. This is the workspace-level page that the user provides (stored as `workspace_page_id` in notion-sync.json or passed via CLI `--parent-page` flag).
- `options.onProgress` — Callback: `(event)` where event is `{ file, status, index, total, pageId?, error? }`. Status is one of: 'creating', 'updating', 'skipped', 'error'.
- `options.dryRun` — If true, run change detection but skip all Notion API calls. Return what would happen.

**Algorithm (breadth-first, parents before children):**

1. **Load state:** `loadSyncState(cwd)` to get current mappings
2. **Build hierarchy:** `buildHierarchy(planningDir)` to get the page tree
3. **Flatten to ordered list:** Walk the tree breadth-first to produce a flat ordered list of files to sync. Parents MUST come before children. The order is:
   - Root file (PROJECT.md)
   - Root-level children (ROADMAP.md, REQUIREMENTS.md, STATE.md, etc.)
   - Phase folder virtual pages (one per phase directory)
   - Phase folder children (the .md files inside each phase dir)
4. **Process each item:**
   a. For each file in the ordered list:
      - Determine its parent page ID:
        - Root file (PROJECT.md) → parentPageId from options (workspace page)
        - Root-level children → root file's page ID (from sync state, just created or previously synced)
        - Phase folder virtual pages → root file's page ID
        - Phase folder children → their phase folder's page ID
      - Run `needsSync(filePath, syncState, projectSlug)` to check if file changed
      - If `needsSync.needsSync === false`, emit 'skipped' progress event and continue
      - If needs sync:
        - Convert file: `convertFile(filePath)` to get blocks
        - Flatten blocks from chunks: concatenate all chunks into single blocks array for page operations
        - Check if page ID exists in sync state:
          - If exists: validate page exists via `validatePageExists`, then `updatePage`. If page not found (stale ID), remove mapping and fall through to create.
          - If not exists: `createPage` with correct parentPageId
        - Emit 'creating' or 'updating' progress event
        - On success: Update sync state with new mapping `{ page_id, hash, syncedAt }` and `saveSyncState(cwd, syncState)` immediately (atomic per-file persistence)
        - On error: Emit 'error' progress event, log error, continue to next file (do not abort batch)
   b. For phase folder virtual pages (no .md file to convert):
      - Check if phase_pages[folderName] exists in project state
      - If not: create empty page with folder title as parent of root page → store in phase_pages
      - If exists: validate it still exists, skip if valid
      - These pages have no content blocks — just a title

5. **Return results:**
```javascript
{
  total: number,        // Total files processed
  created: number,      // New pages created
  updated: number,      // Existing pages updated
  skipped: number,      // Unchanged files skipped
  errors: number,       // Files that failed
  errorDetails: [{ file, error }]  // Error details for reporting
}
```

**Dry-run behavior:** Run steps 1-3, then for step 4 check needsSync but skip all Notion API calls. Return results with what *would* happen (creating vs updating vs skipped based on state).

**Important implementation details:**
- Process files sequentially (not parallel) to respect Notion rate limits and ensure parent pages exist before children
- Phase folder virtual pages are tracked in `syncState.projects[slug].phase_pages[folderName]` (already in schema from Phase 6)
- File paths in sync state use relative paths from cwd (e.g., `.planning/PROJECT.md`, `.planning/phases/08-name/08-RESEARCH.md`)
- Use path.relative(cwd, absolutePath) to normalize paths for sync state keys
- Import from Plan 01 modules: `require('./hierarchy.js')`, `require('./change-detector.js')`, `require('./page-manager.js')`
- Import converter: `require('./converter.js')`
- Import sync-state: `require('./sync-state.js')`

**sync-state.js modifications:**
- The existing `setPageId` stores just a string (pageId). Extend the doc_pages values to store objects: `{ page_id: string, hash: string, syncedAt: string }`.
- Update `getPageId` to handle both old format (string) and new format (object) — if value is string, return it as page_id; if object, return value.page_id. This provides backward compatibility.
- Add new function `setPageMapping(state, projectSlug, filePath, mapping)` that sets the full mapping object `{ page_id, hash, syncedAt }` in doc_pages. Keep existing `setPageId` for backward compatibility.
- Add new function `getPageMapping(state, projectSlug, filePath)` that returns the full mapping object or null. Returns `{ page_id, hash, syncedAt }` if object, or `{ page_id: value, hash: null, syncedAt: null }` if legacy string.
- Export both new functions alongside existing ones.
  </action>
  <verify>
Run `node -e "const so = require('./lib/notion/sync-orchestrator.js'); console.log(typeof so.syncProject)"` — should print `function`.

Run `node -e "const ss = require('./lib/notion/sync-state.js'); console.log(Object.keys(ss))"` — should include `setPageMapping` and `getPageMapping` alongside existing exports.

Run `node -e "const ss = require('./lib/notion/sync-state.js'); const state = ss.initSyncState('.'); ss.setPageMapping(state, 'test', 'file.md', { page_id: 'abc', hash: 'def', syncedAt: '2026-01-01' }); const m = ss.getPageMapping(state, 'test', 'file.md'); console.log(m)"` — should return the mapping object.

Verify backward compatibility: `node -e "const ss = require('./lib/notion/sync-state.js'); const state = { version: 1, workspace_page_id: null, projects: { test: { doc_pages: { 'old.md': 'legacy-id' } } } }; console.log(ss.getPageMapping(state, 'test', 'old.md'))"` — should return `{ page_id: 'legacy-id', hash: null, syncedAt: null }`.
  </verify>
  <done>
sync-orchestrator.js exports syncProject() that coordinates the full sync pipeline: builds hierarchy, detects changes via hashing, creates/updates Notion pages in breadth-first order (parents before children), persists state atomically after each file, and supports dry-run mode. sync-state.js extended with setPageMapping/getPageMapping for rich doc_pages entries (page_id + hash + syncedAt) with backward compatibility for legacy string format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire sync subcommand into CLI with progress indicators</name>
  <files>bin/notion-sync.js</files>
  <action>
Add `sync` subcommand to bin/notion-sync.js:

**Usage:** `node bin/notion-sync.js sync [options]`

**Options:**
- `--cwd <path>` — Working directory (default: process.cwd())
- `--parent-page <id>` — Notion parent page ID (overrides workspace_page_id from notion-sync.json)
- `--project <slug>` — Project slug for sync-state tracking (default: 'default')
- `--dry-run` — Preview what would sync without making Notion API calls

**Handler function `handleSync(options)`:**

1. Create Notion client via `createNotionClient(cwd)` (skip if dry-run — use null client)
2. Determine parent page ID:
   - First check `--parent-page` CLI flag
   - Then check `syncState.workspace_page_id` from notion-sync.json
   - If neither found, print error: "No parent page ID specified. Use --parent-page <id> or set workspace_page_id in .planning/notion-sync.json" and exit(1)
   - On first use with --parent-page, save the ID to `syncState.workspace_page_id` for subsequent runs
3. Call `syncProject(notion, { cwd, projectSlug, parentPageId, dryRun, onProgress })` with progress callback
4. Progress callback prints per-file status:
   ```
   ● Creating  PROJECT.md (1/15)
   ◐ Updating  ROADMAP.md (2/15)
   ○ Skipped   STATE.md (3/15)
   ✗ Error     broken.md (4/15) — Page not found
   ```
   Use color codes:
   - `creating` → green `●`
   - `updating` → yellow `◐`
   - `skipped` → dim `○`
   - `error` → red `✗`
5. After sync completes, print summary:
   ```
   ✓ Sync complete: 12 created, 2 updated, 1 skipped, 0 errors (15 total)
   ```
   Or for dry-run:
   ```
   [DRY RUN] Would sync 15 files: 12 new, 2 changed, 1 unchanged
   ```
6. Exit with code 0 on success, code 1 if all files failed, code 0 with warnings if partial failures

**Update printHelp()** to include sync command:
```
  sync              Push .planning/ markdown to Notion pages
```

**Update main() routing** to handle 'sync' command, parse --parent-page and --project flags.

**Important details:**
- For dry-run, still create the Notion client (needed if we want to validate parent page), but pass dryRun to syncProject which skips API calls
- Actually, for dry-run we can skip client creation entirely since syncProject won't make API calls. Use `null` as client and document that dry-run doesn't validate against Notion.
- Progress output goes to stderr via process.stderr.write (not console.log) so stdout can be piped if needed. Actually, use console.log for progress (matching existing pattern in handleConvert). Keep it simple.
- Import syncProject: `const { syncProject } = require('../lib/notion/sync-orchestrator.js')`
- Import sync-state for reading workspace_page_id: `const { loadSyncState, saveSyncState } = require('../lib/notion/sync-state.js')`
  </action>
  <verify>
Run `node bin/notion-sync.js help` — should show sync command in help output.

Run `node bin/notion-sync.js sync --dry-run --parent-page fake-id` — should run change detection against .planning/ files and show what would be created/updated/skipped (no Notion API calls). If notion-sync.json has no mappings, all files should show as "would create".

Run `node bin/notion-sync.js sync` without --parent-page and without workspace_page_id in notion-sync.json — should print the "No parent page ID specified" error message and exit(1).
  </verify>
  <done>
CLI sync subcommand is fully wired: handles --parent-page, --project, --dry-run flags; prints per-file progress with color-coded status indicators (creating/updating/skipped/error); shows completion summary; persists workspace_page_id for subsequent runs; exits with appropriate codes.
  </done>
</task>

</tasks>

<verification>
Full dry-run sync test:
```bash
node bin/notion-sync.js sync --dry-run --parent-page test-page-id
```
Should list all .planning/ .md files with "would create" status and summary count.

CLI help includes sync command:
```bash
node bin/notion-sync.js help | grep sync
```

Module loading chain works end-to-end:
```bash
node -e "
  const so = require('./lib/notion/sync-orchestrator.js');
  const ss = require('./lib/notion/sync-state.js');
  const h = require('./lib/notion/hierarchy.js');
  const cd = require('./lib/notion/change-detector.js');
  const pm = require('./lib/notion/page-manager.js');
  console.log('All Phase 8 modules loaded successfully');
"
```

Sync state backward compatibility:
```bash
node -e "
  const ss = require('./lib/notion/sync-state.js');
  const state = { version: 1, workspace_page_id: null, projects: { test: { doc_pages: { 'f.md': 'old-id' } } } };
  console.log('Legacy getPageId:', ss.getPageId(state, 'test', 'f.md'));
  console.log('New getPageMapping:', JSON.stringify(ss.getPageMapping(state, 'test', 'f.md')));
"
```
</verification>

<success_criteria>
- syncProject() orchestrates full sync pipeline: hierarchy → change detection → create/update → state persistence
- Files sync in breadth-first order (parents before children)
- Phase folder virtual pages created as intermediate grouping nodes
- Hash-based change detection skips unchanged files
- State persists atomically after each file (resume-on-error)
- Stale page IDs detected and handled (removed from state, new page created)
- CLI sync subcommand works with --parent-page, --project, --dry-run flags
- Progress output shows per-file status with color-coded indicators
- Dry-run mode previews sync without Notion API calls
- sync-state.js extended with rich mappings (page_id + hash + syncedAt) while maintaining backward compatibility
</success_criteria>

<output>
After completion, create `.planning/phases/08-page-hierarchy-incremental-sync/08-02-SUMMARY.md`
</output>

---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: [01-01, 01-02]
files_modified:
  - ".claude/get-shit-done/bin/gsd-tools.js"
  - ".claude/get-shit-done/workflows/create-project.md"
autonomous: false
must_haves:
  truths:
    - "Existing flat .planning/ structure continues to work as-is for single-project usage without any migration"
    - "Migration is only triggered when PM creates a second project (opts into multi-project)"
    - "Before migration, entire flat structure is backed up to .planning/_backup/ with timestamp"
    - "After migration, existing work is in .planning/{project-slug}/v1/ with correct internal layout"
    - "PROJECT.md is placed at project root (.planning/{slug}/PROJECT.md), not in version folder"
    - "After migration, PM can immediately use the migrated project and the newly created project"
    - "PM confirms migration before it proceeds (not silent/automatic)"
  artifacts:
    - path: ".claude/get-shit-done/bin/gsd-tools.js"
      provides: "migrateToNested() function and migration verification"
      contains: "migrateToNested"
  key_links:
    - from: "create-project workflow step 3"
      to: "migrateToNested() in gsd-tools.js"
      via: "Migration check when has_flat_structure is true"
      pattern: "migrateToNested"
    - from: "migrateToNested()"
      to: ".planning/_backup/"
      via: "fs.cpSync recursive copy before any destructive operation"
      pattern: "_backup"
    - from: "migrateToNested()"
      to: ".planning/{slug}/v1/"
      via: "fs.renameSync moving flat files into project structure"
      pattern: "renameSync"
---

<objective>
Implement migration from flat .planning/ structure to nested multi-project structure, with backup safety net and verification.

Purpose: PMs with existing single-project setups must be able to safely transition to multi-project support. Per user decision, migration is only triggered when creating a second project, includes mandatory backup, and requires confirmation. This completes INFRA-05.

Output: Migration logic in gsd-tools.js, updated create-project workflow to trigger migration, and a human verification checkpoint.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@.claude/get-shit-done/bin/gsd-tools.js
@.claude/get-shit-done/workflows/create-project.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement migration logic and integrate with create-project workflow</name>
  <files>
    .claude/get-shit-done/bin/gsd-tools.js
    .claude/get-shit-done/workflows/create-project.md
  </files>
  <action>
**Add migration functions to gsd-tools.js:**

**1. migrateToNested(cwd, existingProjectName, existingProjectDescription)**

Migrates flat .planning/ structure into a project subfolder. Steps:

a. **Create backup** (per user decision: always create backup in .planning/_backup/):
   - Create `.planning/_backup/` if not exists
   - Generate timestamped backup folder: `.planning/_backup/flat-{YYYY-MM-DDTHH-mm-ss}/`
   - Copy everything from `.planning/` into backup EXCEPT `_backup/` itself
   - Use `fs.cpSync(src, dest, { recursive: true })` (available since Node 16.7.0, matches engine requirement)

b. **Verify backup:**
   - Check that key files exist in backup: STATE.md, PROJECT.md, ROADMAP.md
   - If any missing, abort with error: `Backup verification failed: {file} missing. Aborting migration.`
   - Count total files in backup vs source as sanity check

c. **Generate slug** for existing project:
   - Use `generateSlugInternal(existingProjectName)`
   - If collision with an existing directory (shouldn't happen on first migration but be safe), append counter

d. **Create project structure:**
   - Create `.planning/{slug}/` and `.planning/{slug}/v1/`

e. **Move files:**
   - Move `PROJECT.md` to `.planning/{slug}/PROJECT.md` (project root, per user decision)
   - Move `STATE.md`, `ROADMAP.md`, `REQUIREMENTS.md`, `config.json`, `phases/`, `research/`, `codebase/`, `quick/`, `todos/`, `archive/` to `.planning/{slug}/v1/`
   - Skip: `_backup/` directory, `.active-project` file
   - For each item: check if exists before moving (not all directories may be present)
   - Use `fs.renameSync(src, dest)` for moves (atomic within same filesystem, which they are since both under .planning/)

f. **Update STATE.md** in new location:
   - Read `.planning/{slug}/v1/STATE.md`
   - Add `**current_project:** {slug}` and `**current_version:** v1` fields
   - Insert after `## Current Position` heading (or at the top of that section)
   - Write back using fs.writeFileSync

g. **Set active project:**
   - Write slug to `.planning/.active-project`

h. **Clean up .planning/ root:**
   - After successful moves, verify that .planning/{slug}/v1/ has the expected files
   - Root should now only contain: `_backup/`, `.active-project`, `{slug}/`, and `config.json` (global config stays at root)
   - NOTE: If config.json existed, it was moved to v1/. Also keep a copy at root as global config. Or better: leave config.json at root (don't move it) since it's global per PathResolver design.

i. **Return result:**
   ```javascript
   {
     migrated: true,
     project_slug: slug,
     backup_path: backupPath,
     files_moved: count,
     verification: { state: exists, project: exists, roadmap: exists, phases: exists }
   }
   ```

**2. verifyMigration(cwd, slug)**

Post-migration verification:
- Check `.planning/{slug}/PROJECT.md` exists
- Check `.planning/{slug}/v1/STATE.md` exists
- Check `.planning/{slug}/v1/ROADMAP.md` exists (if it existed before)
- Check `.planning/{slug}/v1/phases/` exists (if it existed before)
- Check `.planning/_backup/` exists with content
- Return `{ valid: true/false, issues: [] }`

**3. Add `project migrate` subcommand** to the project command dispatcher:
```javascript
} else if (subcommand === 'migrate') {
  // args[2] = existingProjectName, args[3] = description
  const result = migrateToNested(cwd, args[2], args[3] || '');
  output(result, raw);
} else if (subcommand === 'verify-migration') {
  const result = verifyMigration(cwd, args[2]);
  output(result, raw);
}
```

**4. Update create-project workflow** (create-project.md):

In Step 3 (Migration Check), flesh out the migration flow:

When `has_flat_structure` is true AND this is the first project being created in multi-project mode:

a. Read existing PROJECT.md to suggest a name for the existing project
b. Display: "I notice you have an existing project in .planning/. To support multiple projects, I need to move your existing work into a project folder."
c. Per user decision: "I'll move your existing work into a project folder. OK?"
d. Use AskUserQuestion to confirm migration
e. Ask what to name the existing project (suggest from PROJECT.md title)
f. Call `node gsd-tools.js project migrate "{name}" "{description}"`
g. Verify: `node gsd-tools.js project verify-migration "{slug}"`
h. Display results and backup location
i. Then proceed to create the NEW project (the one the user originally requested)

**5. Update detectFlatStructure(cwd)** if needed:

Should return true when:
- `.planning/` exists
- `.planning/STATE.md` exists (flat structure has state at root)
- `.planning/.active-project` does NOT exist (not yet multi-project)
- No subdirectories in .planning/ contain PROJECT.md (no projects exist yet)

**IMPORTANT edge cases:**
- config.json handling: Keep config.json at .planning/ root (global). If it was also the project config, copy it into v1/ as well. This way global config persists and project config inherits.
- If REQUIREMENTS.md doesn't exist (optional file), skip it during move.
- If research/, codebase/, quick/, todos/, archive/ directories don't exist, skip them.
- If migration fails partway, the backup ensures recovery. Do NOT delete backup automatically.
  </action>
  <verify>
Verify migration function exists:
```bash
grep -n "migrateToNested\|verifyMigration" .claude/get-shit-done/bin/gsd-tools.js | head -10
```

Verify project migrate subcommand exists:
```bash
grep -n "'migrate'" .claude/get-shit-done/bin/gsd-tools.js
```

Run existing test suite:
```bash
node --test .claude/get-shit-done/bin/gsd-tools.test.js
```

Test the detect function:
```bash
node ./.claude/get-shit-done/bin/gsd-tools.js init create-project --raw
```
Should show `has_flat_structure: true` since current .planning/ is flat.
  </verify>
  <done>migrateToNested() and verifyMigration() functions exist in gsd-tools.js. `project migrate` and `project verify-migration` subcommands work. create-project.md workflow includes migration check with user confirmation. detectFlatStructure correctly identifies the current flat structure. Existing tests pass.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify full project lifecycle works end-to-end</name>
  <files>none - verification only</files>
  <action>
Run the verification commands listed below to confirm the complete Phase 1 multi-project infrastructure works end-to-end. This covers all work from Plans 01, 02, and 03 together.
  </action>
  <verify>
**Test 1: Verify flat mode still works (backward compatibility)**
```bash
node ./.claude/get-shit-done/bin/gsd-tools.js init plan-phase 1
```
Should return valid JSON with phase info.

**Test 2: List projects (should be empty or detect flat structure)**
```bash
node ./.claude/get-shit-done/bin/gsd-tools.js project list --raw
```
Should return empty array or indicate flat mode.

**Test 3: Create a test project**
```bash
node ./.claude/get-shit-done/bin/gsd-tools.js project create "Test Project Alpha" "A test project for verification"
```
Should create .planning/test-project-alpha/ with PROJECT.md and v1/ subfolder.

**Test 4: Verify folder structure**
```bash
ls -la .planning/test-project-alpha/
ls -la .planning/test-project-alpha/v1/
```
Should show PROJECT.md at root and STATE.md + phases/ in v1/.

**Test 5: Switch to the new project**
```bash
node ./.claude/get-shit-done/bin/gsd-tools.js project switch "test-project-alpha"
cat .planning/.active-project
```
Should contain: test-project-alpha

**Test 6: Clean up test project**
```bash
rm -rf .planning/test-project-alpha
rm -f .planning/.active-project
```
  </verify>
  <done>All six tests pass: flat mode backward compatible, project creation produces correct folder hierarchy, switch updates .active-project file, migration logic exists. Human has verified end-to-end functionality.</done>
</task>

</tasks>

<verification>
1. `grep -c "migrateToNested" .claude/get-shit-done/bin/gsd-tools.js` returns 2+ (function def + usage)
2. `node ./.claude/get-shit-done/bin/gsd-tools.js project list --raw` returns valid JSON
3. Migration creates backup before moving files
4. Migration places PROJECT.md at project root, other files in v1/
5. Backward compatibility: flat mode commands work identically to before Phase 1
6. `node --test .claude/get-shit-done/bin/gsd-tools.test.js` passes
</verification>

<success_criteria>
- Migration function exists with backup-first, verify-after approach
- create-project workflow triggers migration when flat structure detected and PM creates second project
- Migration backs up to .planning/_backup/ with timestamp
- Migration moves PROJECT.md to project root, everything else to v1/
- Migration updates STATE.md with current_project and current_version
- Backward compatibility verified: flat mode works identically to before
- Full project lifecycle (create, switch, list) verified by human
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>

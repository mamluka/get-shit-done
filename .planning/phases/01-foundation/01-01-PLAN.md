---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - "get-shit-done/bin/gsd-tools.js"
autonomous: true
must_haves:
  truths:
    - "All file operations in gsd-tools.js resolve paths through a centralized PathResolver, not hardcoded .planning/ literals"
    - "PathResolver detects flat vs nested mode by checking STATE.md for current_project/current_version fields"
    - "In flat mode (no current_project), PathResolver returns .planning/{file} paths identical to current behavior"
    - "In nested mode, PathResolver returns .planning/{project}/v{N}/{file} paths"
    - "PROJECT.md resolves to project root (.planning/{project}/PROJECT.md) not version folder"
    - "config.json resolves to .planning/config.json (global) in both modes"
  artifacts:
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "PathResolver class and refactored path resolution"
      contains: "class PathResolver"
  key_links:
    - from: "PathResolver.resolve()"
      to: "Every function that builds .planning/ paths"
      via: "PathResolver.getInstance(cwd) singleton pattern"
      pattern: "PathResolver\\.getInstance"
    - from: "PathResolver.detectMode()"
      to: "STATE.md current_project field"
      via: "Regex parsing of STATE.md content"
      pattern: "current_project"
---

<objective>
Create the PathResolver abstraction layer in gsd-tools.js and refactor all hardcoded `.planning/` path references to use it.

Purpose: This is the foundation for all multi-project support. Every file operation must go through a centralized resolver that knows whether the user is in flat mode (single project, backward compatible) or nested mode (multi-project). Without this, no other Phase 1 work can function.

Output: gsd-tools.js with PathResolver class and all 40+ hardcoded `.planning/` path references refactored to use it.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<constraints>
CRITICAL: The .claude/ folder is the INSTALLED framework (local to each user). It is NOT part of the project codebase and must NEVER be modified, committed, or referenced as a target file. All source code changes go to the ROOT get-shit-done/ folder. The mapping is:
- Source code: get-shit-done/bin/gsd-tools.js (MODIFY THIS)
- Installed copy: .claude/get-shit-done/bin/gsd-tools.js (NEVER TOUCH)
- Source workflows: get-shit-done/workflows/*.md (MODIFY THIS)
- Installed workflows: .claude/get-shit-done/workflows/*.md (NEVER TOUCH)
- Source commands: commands/gsd/*.md (MODIFY THIS)
- Installed commands: .claude/commands/gsd/*.md (NEVER TOUCH)
</constraints>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
@get-shit-done/bin/gsd-tools.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PathResolver class in gsd-tools.js</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Add a PathResolver class near the top of gsd-tools.js (after the helpers section, before any command functions). The class must:

1. **Constructor(cwd):** Store cwd, compute planningRoot as `path.join(cwd, '.planning')`, call detectMode(), and if nested mode, call loadProjectContext().

2. **detectMode():** Read STATE.md at `.planning/STATE.md`. If file doesn't exist, return 'flat'. If content contains both `current_project:` and `current_version:` fields with non-empty values, return 'nested'. Otherwise return 'flat'.

3. **loadProjectContext():** Parse STATE.md for `current_project` and `current_version` field values. Store as this.currentProject and this.currentVersion.

4. **resolve(relativePath):** The core method. Behavior:
   - Global files (config.json) always resolve to `.planning/config.json` regardless of mode
   - Flat mode: resolve to `.planning/{relativePath}` (identical to current behavior)
   - Nested mode without active project: throw Error('No active project. Run /gsd:switch-project or /gsd:new-project to select one.')
   - Nested mode with PROJECT.md: resolve to `.planning/{currentProject}/PROJECT.md` (project root, not version folder per user decision)
   - Nested mode for everything else: resolve to `.planning/{currentProject}/{currentVersion}/{relativePath}`

5. **projectRoot(projectSlug):** Return `.planning/{projectSlug}` (for creating new projects, listing)

6. **versionRoot(projectSlug, version):** Return `.planning/{projectSlug}/{version}`

7. **listProjects():** Read `.planning/` directory, filter to directories that are not `_backup`, return list of project slugs that contain a PROJECT.md

8. **isNested():** Return this.mode === 'nested'

9. **Static getInstance(cwd):** Singleton per cwd value. Cache instance and return cached if cwd matches. This avoids re-reading STATE.md on every call.

10. **Static clearCache():** For testing - clears the singleton cache.

IMPORTANT constraints:
- Zero external dependencies. Use only Node.js built-in fs and path modules (per existing project constraint: `"dependencies": {}` in package.json).
- The existing `generateSlugInternal()` function already handles slug generation without slugify library. Do not add slugify.
- Use synchronous fs operations (fs.readFileSync, fs.existsSync) matching the existing codebase pattern. The codebase is synchronous throughout.
- Do NOT use write-file-atomic. The existing codebase uses fs.writeFileSync. Keep consistent.
- The resolve() method must return absolute paths using path.join(cwd, ...) to match how pathExistsInternal() works.
  </action>
  <verify>
Run the existing test suite to confirm no regressions:
```bash
node --test get-shit-done/bin/gsd-tools.test.js
```
Verify the PathResolver class exists:
```bash
grep -n "class PathResolver" get-shit-done/bin/gsd-tools.js
```
  </verify>
  <done>PathResolver class exists in gsd-tools.js with resolve(), detectMode(), loadProjectContext(), projectRoot(), versionRoot(), listProjects(), isNested(), getInstance(), and clearCache() methods. Existing tests still pass.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor all hardcoded .planning/ paths to use PathResolver</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Systematically replace every hardcoded `.planning/` path construction in gsd-tools.js with PathResolver calls. There are approximately 40+ locations.

**Approach:**
1. Search for all `path.join(cwd, '.planning'` patterns
2. Search for all string literals containing `.planning/`
3. For each, determine which resolve() call replaces it

**Replacement patterns:**

A. **loadConfig():** `path.join(cwd, '.planning', 'config.json')` becomes `PathResolver.getInstance(cwd).resolve('config.json')` — config.json is global, always at .planning/ root.

B. **All init commands (cmdInitExecutePhase, cmdInitPlanPhase, cmdInitNewProject, etc.):** Each `pathExistsInternal(cwd, '.planning/STATE.md')` becomes `pathExistsInternal(cwd, PathResolver.getInstance(cwd).resolve('STATE.md'))` — BUT since pathExistsInternal already joins cwd, and PathResolver.resolve() returns absolute paths, you need to adjust. Use the resolver's planningRoot for existence checks, OR change pathExistsInternal calls to just use the absolute path from resolver.

Actually, simpler approach: Create a helper `resolvePlanning(cwd, relativePath)` that wraps PathResolver:
```javascript
function resolvePlanning(cwd, relativePath) {
  return PathResolver.getInstance(cwd).resolve(relativePath);
}
```
Then replace `path.join(cwd, '.planning', 'STATE.md')` with `resolvePlanning(cwd, 'STATE.md')`.

And for pathExistsInternal calls like `pathExistsInternal(cwd, '.planning/STATE.md')`, since resolver returns absolute paths, change to:
```javascript
fs.existsSync(resolvePlanning(cwd, 'STATE.md'))
```

C. **Phase directory paths:** `.planning/phases/` becomes resolver-aware. Add a `resolvePhases(cwd)` helper or use `resolvePlanning(cwd, 'phases')`.

D. **Specific patterns to handle:**
- `path.join(cwd, '.planning', 'config.json')` in loadConfig() - global, use resolver
- `'.planning/'` as git staging path in commit command - keep as-is, this is a git add path
- `'.planning/phases/${dirName}'` in scaffold commands - use resolver
- `'.planning/STATE.md'` in all init commands - use resolver
- `'.planning/ROADMAP.md'` in all init commands - use resolver
- `'.planning/PROJECT.md'` in all init commands - use resolver
- `'.planning/config.json'` in config commands - use resolver (global)
- `'.planning/todos/'` paths - use resolver
- `'.planning/quick/'` paths - use resolver
- `'.planning/codebase'` paths - use resolver
- `'.planning/archive'` paths - use resolver
- `'.planning/research/'` paths - use resolver

E. **CRITICAL: Do not break the git commit staging path.** The commit function uses `'.planning/'` as a fallback staging path. In nested mode this should still work because git add stages everything under .planning/. Leave this as-is.

F. **For getMilestoneInfo():** Replace `path.join(cwd, '.planning', 'ROADMAP.md')` with resolver call.

G. **For cmdConfigEnsureSection():** Replace hardcoded config.json path with resolver.

**Testing after refactor:**
- Run `node ./get-shit-done/bin/gsd-tools.js state load` from the repo root to confirm flat mode still works
- Run existing test suite
- Confirm all init commands still return valid JSON

IMPORTANT: Since no active project exists yet (flat mode), PathResolver.detectMode() will return 'flat' and all paths resolve identically to before. This means zero behavioral change for existing workflows. The refactor is purely structural — preparing for nested mode support in Plan 02.
  </action>
  <verify>
Run the full test suite:
```bash
node --test get-shit-done/bin/gsd-tools.test.js
```
Verify no remaining hardcoded `.planning/` path.join patterns (excluding comments, strings used for display, and git staging):
```bash
grep -n "path\.join(cwd.*'\.planning'" get-shit-done/bin/gsd-tools.js | grep -v "// " | grep -v "PathResolver" | wc -l
```
Target: 0 remaining (or only the git staging fallback in commit function).

Test that flat mode still works:
```bash
node ./get-shit-done/bin/gsd-tools.js init plan-phase 1
```
Should return valid JSON with phase_found: true.
  </verify>
  <done>All hardcoded .planning/ path constructions replaced with PathResolver calls. Flat mode behavior is unchanged — all existing commands produce identical output. Test suite passes. The codebase is ready for nested mode support.</done>
</task>

</tasks>

<verification>
1. `node --test get-shit-done/bin/gsd-tools.test.js` passes with zero failures
2. `node ./get-shit-done/bin/gsd-tools.js init plan-phase 1` returns valid JSON
3. `node ./get-shit-done/bin/gsd-tools.js state load` works correctly
4. `grep -c "class PathResolver" get-shit-done/bin/gsd-tools.js` returns 1
5. No behavioral changes in flat mode — all existing workflows function identically
</verification>

<success_criteria>
- PathResolver class exists with mode detection (flat/nested)
- All 40+ hardcoded .planning/ paths refactored to use PathResolver
- Flat mode (current state) works identically to before refactor
- Nested mode path resolution logic is implemented and ready for activation
- Existing test suite passes without modification
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>

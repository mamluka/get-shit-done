---
phase: 21-update-semantics-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/jira/sync-state.js
  - get-shit-done/workflows/sync-jira.md
autonomous: false

must_haves:
  truths:
    - "Re-running sync-jira does NOT create duplicate epics or tickets"
    - "Changed planning content updates existing Jira tickets via editJiraIssue"
    - "New phases or requirements added since last sync create new tickets under the existing epic"
    - "jira-sync.json tracks every synced ticket with Jira key and granularity metadata (type, phase_number, category, requirement_id)"
    - "User sees preview showing create vs update vs unchanged counts before execution"
  artifacts:
    - path: "lib/jira/sync-state.js"
      provides: "Sync state read/write/diff operations for jira-sync.json"
      exports: ["loadSyncState", "saveSyncState", "diffTickets"]
    - path: "get-shit-done/workflows/sync-jira.md"
      provides: "Extended workflow with update detection, create/update routing, and incremental save"
      contains: "detect_existing_sync"
  key_links:
    - from: "lib/jira/sync-state.js"
      to: ".planning/jira-sync.json"
      via: "fs.readFileSync/writeFileSync with multi-project path resolution"
      pattern: "loadSyncState.*readFileSync"
    - from: "lib/jira/sync-state.js diffTickets"
      to: "lib/jira/ticket-mapper.js mapTickets"
      via: "Compares current ticket-mapper output against stored sync state"
      pattern: "diffTickets.*toCreate.*toUpdate.*unchanged"
    - from: "get-shit-done/workflows/sync-jira.md"
      to: "lib/jira/sync-state.js"
      via: "Node require calls in workflow bash blocks"
      pattern: "require.*sync-state"
    - from: "get-shit-done/workflows/sync-jira.md create_tickets step"
      to: "mcp__jira__editJiraIssue"
      via: "Update path calls editJiraIssue instead of createJiraIssue"
      pattern: "editJiraIssue.*summary.*description"
    - from: "get-shit-done/workflows/sync-jira.md assign_team step"
      to: "create_tickets step ticket keys (both created and updated)"
      via: "Collects ALL ticket keys from both toCreate results and toUpdate results into a unified list for assignment"
      pattern: "ticket.*key.*created.*updated"
---

<objective>
Create incremental sync capability so re-running /gsd-pm:sync-jira updates existing Jira tickets instead of creating duplicates, and creates new tickets only for newly added planning artifacts.

Purpose: Without update semantics, every sync run creates a fresh set of duplicate tickets. This phase makes sync idempotent by tracking what was previously synced in jira-sync.json and routing to create or update based on diff analysis.

Output: lib/jira/sync-state.js module + extended sync-jira.md workflow with create/update/skip routing
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-epic-ticket-creation/19-01-SUMMARY.md
@.planning/phases/20-team-assignment/20-01-SUMMARY.md

@lib/jira/issue-creator.js
@lib/jira/ticket-mapper.js
@lib/jira/team-fetcher.js
@get-shit-done/workflows/sync-jira.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync-state module for jira-sync.json read/write/diff</name>
  <files>lib/jira/sync-state.js</files>
  <action>
Create `lib/jira/sync-state.js` with three exported functions. Follow the exact patterns from issue-creator.js and ticket-mapper.js (CommonJS, JSDoc, resolvePlanningPath helper, graceful error returns).

**resolvePlanningPath(cwd, filename):** Copy the same helper from issue-creator.js (checks .active-project for multi-project layout).

**loadSyncState(cwd):**
- Read `.planning/jira-sync.json` using resolvePlanningPath
- Return the parsed JSON object if it exists and is valid
- Return `null` if file does not exist (first run)
- Return `{ error: '...' }` if file exists but is corrupt/unreadable
- The expected schema of jira-sync.json (matching what save_sync_state step already writes):
  ```
  {
    milestone: string,
    granularity: string,
    project_key: string,
    cloud_id: string,
    epic: { key: string, summary: string, assignee?: { accountId, displayName } },
    tickets: [{ key: string, summary: string, phase?: string, category?: string, requirement_id?: string, assignee?: {...} }],
    synced_at: ISO string,
    failed_count: number
  }
  ```

**saveSyncState(cwd, syncData):**
- Write syncData to `.planning/jira-sync.json` using resolvePlanningPath
- Use `JSON.stringify(syncData, null, 2) + "\n"` for formatting
- Return `{ success: true }` or `{ error: '...' }` on write failure

**diffTickets(existingState, currentTickets, granularity):**
- Takes the loaded sync state (from loadSyncState), the current ticket array (from ticket-mapper's mapTickets().tickets), and the granularity string
- Returns `{ toCreate: [], toUpdate: [], unchanged: [], epicExists: boolean, existingEpicKey: string|null }`
- Matching logic depends on granularity:
  - For `phase` granularity: match on `phase_number` (ticket.phase_number === stored.phase)
  - For `category` granularity: match on `category` (ticket.category === stored.category)
  - For `requirement` granularity: match on `requirement_id` (ticket.requirement_id === stored.requirement_id)
- If existingState is null (first run), ALL currentTickets go to `toCreate`, epicExists is false
- If existingState exists:
  - Epic: epicExists = true, existingEpicKey = existingState.epic.key
  - For each ticket in currentTickets: if a matching ticket exists in existingState.tickets, put in `toUpdate` with the existing Jira key attached; otherwise put in `toCreate`
  - For each ticket in existingState.tickets not matched by currentTickets: ignore (do not delete -- one-way push only)
- Each item in `toUpdate` should have shape: `{ ...currentTicket, jira_key: existingTicket.key }`
- Each item in `toCreate` keeps original shape from ticket-mapper
- Each item in `unchanged` has shape: `{ ...existingTicket }` (tickets that match but have identical content -- SKIP this optimization for now, treat all matches as toUpdate since content comparison is complex and updates are idempotent)

So effectively: matched = toUpdate, unmatched = toCreate, unchanged = [] (always empty for v1).

Include JSDoc comments on all functions matching the style in issue-creator.js.
  </action>
  <verify>
Run: `node -e 'var ss = require("./lib/jira/sync-state.js"); console.log(Object.keys(ss));'`
Expected output includes: loadSyncState, saveSyncState, diffTickets

Run: `node -e 'var ss = require("./lib/jira/sync-state.js"); var result = ss.loadSyncState(process.cwd()); console.log(result);'`
Expected: null (no jira-sync.json exists yet)

Run: `node -e 'var ss = require("./lib/jira/sync-state.js"); var diff = ss.diffTickets(null, [{type:"phase", phase_number:17, title:"test"}], "phase"); console.log(JSON.stringify(diff));'`
Expected: toCreate has 1 item, toUpdate has 0, epicExists is false
  </verify>
  <done>
sync-state.js exports loadSyncState, saveSyncState, and diffTickets. loadSyncState returns null when no file exists. diffTickets correctly categorizes tickets as toCreate when no prior state exists, and as toUpdate when prior state has matching tickets.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend sync-jira workflow with update detection and create/update routing</name>
  <files>get-shit-done/workflows/sync-jira.md</files>
  <action>
Modify the sync-jira.md workflow to support incremental sync. The changes span multiple steps:

**1. Add a new step "detect_existing_sync" AFTER "choose_granularity" (step 5) and BEFORE "preview_and_approve" (step 6):**

This step loads existing sync state and determines the sync mode:

```bash
SYNC_STATE=$(node -e '
var ss = require("./lib/jira/sync-state.js");
var state = ss.loadSyncState(process.cwd());
if (state === null) {
  console.log(JSON.stringify({ mode: "fresh" }));
} else if (state.error) {
  console.log(JSON.stringify({ mode: "error", error: state.error }));
} else {
  console.log(JSON.stringify({ mode: "incremental", state: state }));
}
')
```

- If mode is "fresh": display "No previous sync found. All tickets will be created." Continue normally.
- If mode is "error": display error, stop.
- If mode is "incremental": display summary of existing sync (epic key, ticket count, last synced date). Store state for use in preview step.
  - Also check if granularity has changed: if `state.granularity !== granularity`, display a warning: "Granularity changed from {old} to {new}. All tickets will be created fresh (previous tickets will NOT be deleted from Jira)." Then treat as mode "fresh" for diffing purposes (set existingState to null for diffTickets).

**2. Modify the "preview_and_approve" step (now step 7):**

After building the preview with issue-creator.buildPreview(), run diffTickets:

```bash
DIFF=$(node -e '
var ss = require("./lib/jira/sync-state.js");
var existingState = /* the state loaded in detect_existing_sync, or null if fresh */;
var currentTickets = /* preview.tickets mapped back to ticket-mapper format */;
var diff = ss.diffTickets(existingState, currentTickets, "{granularity}");
console.log(JSON.stringify(diff));
')
```

Modify the preview display to show counts:
- "New tickets to CREATE: {toCreate.length}"
- "Existing tickets to UPDATE: {toUpdate.length}"
- If epicExists: "Epic: {existingEpicKey} (will be updated)" else "Epic: NEW"

Modify the approval prompt:
- Fresh mode: "This will create 1 epic + {N} tickets in {PROJECT_KEY}."
- Incremental mode: "This will update {updateCount} tickets and create {createCount} new tickets in {PROJECT_KEY}. Epic: {epicKey}."

**3. Modify the "create_tickets" step (now step 8):**

Split into two paths based on diff results:

**Epic handling:**
- If epicExists is true (from diff): call `mcp__jira__editJiraIssue` to update the epic's summary and description. Use `issueIdOrKey: existingEpicKey`. Display "Updated epic: {epicKey}".
- If epicExists is false: create epic as before via `mcp__jira__createJiraIssue`. Display "Created epic: {epicKey}".

**Ticket handling:**
- For each item in `toCreate`: call `mcp__jira__createJiraIssue` as before (with parent set to epic key). Display "Created [{N}/{total}] {ticketKey} -- {summary}".
- For each item in `toUpdate`: call `mcp__jira__editJiraIssue` with `issueIdOrKey: ticket.jira_key`, updating `summary` and `description`. Display "Updated [{N}/{total}] {jiraKey} -- {summary}". Do NOT change the parent field on updates.
- Prepend Notion links to description for both creates and updates (same logic as current).

**IMPORTANT -- Collect ALL ticket keys for downstream steps:**
After processing both toCreate and toUpdate, build a unified list of ALL ticket keys that were touched in this run. This list must include:
- Newly created ticket keys (from createJiraIssue responses)
- Updated ticket keys (the existing jira_key from each toUpdate item)
Store this combined list as the "all ticket keys" for use by the assign_team step.

**Completion banner:**
- Fresh mode: Same as current ("Created 1 epic + {N} tickets")
- Incremental mode: "Updated epic + {updateCount} tickets, created {createCount} new tickets in {PROJECT_KEY}"

**4. Modify the "assign_team" step (now step 9):**

Update the assign_team step to operate on ALL ticket keys from the create_tickets step -- both newly created AND updated tickets. The current workflow references "each ticket key from step 7" which only covers created tickets. Change this so:

- The ticket list used for assignment prompts (displaying ticket count, individual assignment parsing) comes from the unified "all ticket keys" list built in the create_tickets step (step 8), which includes BOTH created and updated ticket keys.
- The TICKET_COUNT used in the assignment prompt and progress display reflects the total count of all tickets (created + updated), not just newly created ones.
- The "bulk" assignment path ("all:{N}") iterates over ALL ticket keys (created + updated) and assigns each one.
- The "individual" assignment path ("1:2, 3:1, ...") indexes into the combined ALL ticket keys list, so ticket index 1 might be an updated ticket or a created ticket.
- Display the assignment progress out of the total count: "Assigned [{N}/{ALL_TICKET_COUNT}] {ticket_key}".

This ensures that on incremental sync, updated tickets also get assigned to team members, not just newly created ones.

**5. Modify the "save_sync_state" step (now step 10):**

Replace the current write-from-scratch approach with a merge approach:

- Load existing state via loadSyncState
- Build new state by MERGING:
  - Updated tickets: keep existing key, update summary/metadata
  - Created tickets: add with new key
  - Tickets from previous state not in current run: PRESERVE (do not remove)
- Use saveSyncState to write
- Each ticket in the tickets array must include granularity metadata:
  - phase granularity: include `phase` field (phase number as string)
  - category granularity: include `category` field (category name)
  - requirement granularity: include `requirement_id` field (e.g., "SYNC-01")
- Update `synced_at` to current ISO timestamp
- Preserve assignee data from both existing state and current assignment step

**Step renumbering:** After inserting detect_existing_sync, the steps become:
1. check_jira_mcp
2. check_notion_sync
3. select_jira_project
4. save_jira_config
5. choose_granularity
6. detect_existing_sync (NEW)
7. preview_and_approve (was 6)
8. create_tickets (was 7, now with update logic + unified key collection)
9. assign_team (was 8, now operates on ALL keys from step 8)
10. save_sync_state (was 9, now with merge logic)

Keep the existing step structure and XML format. Do NOT change the workflow's `<purpose>` tag or `<required_reading>` tag. Match the exact formatting style of existing steps.
  </action>
  <verify>
Read the modified sync-jira.md and verify:
1. Step count is 10 (was 9)
2. New "detect_existing_sync" step exists between choose_granularity and preview_and_approve
3. preview_and_approve step references diffTickets
4. create_tickets step has both createJiraIssue and editJiraIssue paths
5. create_tickets step builds a unified list of ALL ticket keys (created + updated)
6. assign_team step references the unified ticket key list from step 8 (not just created keys)
7. save_sync_state step uses saveSyncState and merges with existing state
8. No steps were accidentally deleted

Run: `grep -c '<step name=' get-shit-done/workflows/sync-jira.md` -- should output 10
  </verify>
  <done>
sync-jira.md has 10 steps. detect_existing_sync step loads jira-sync.json and determines fresh vs incremental mode. preview_and_approve shows create vs update counts. create_tickets routes to createJiraIssue for new tickets and editJiraIssue for existing tickets, and builds a unified list of ALL ticket keys. assign_team operates on ALL ticket keys (both created and updated) so team assignment works for incremental syncs. save_sync_state merges new state with existing state preserving unmodified tickets. Granularity metadata (phase/category/requirement_id) is included on every ticket in jira-sync.json.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify incremental sync end-to-end</name>
  <files>get-shit-done/workflows/sync-jira.md</files>
  <action>
Human verification of incremental Jira sync. The sync-jira workflow has been extended with:
1. detect_existing_sync step that loads jira-sync.json and determines fresh vs incremental mode
2. Modified preview showing create vs update counts
3. create_tickets step with editJiraIssue for updates and createJiraIssue for creates
4. assign_team step that operates on ALL ticket keys (created + updated) for team assignment
5. save_sync_state step with merge logic preserving existing ticket data
  </action>
  <verify>
1. Run `/gsd-pm:sync-jira` for a SECOND time (assumes a previous sync was completed in Phase 19/20 testing)
   - Verify it detects the existing sync state and shows "incremental" mode
   - Verify preview shows update counts (not all creates)
   - Approve the sync
   - Verify existing tickets in Jira are UPDATED (not duplicated)
   - Verify jira-sync.json is updated with current timestamp

2. If no previous sync state exists (jira-sync.json was cleaned up):
   - Run sync once (fresh) to establish baseline
   - Run sync again immediately
   - Second run should show all tickets as updates, zero creates
   - Verify no duplicates in Jira

3. On incremental sync, choose "Yes" for team assignment
   - Verify that BOTH updated and newly created tickets are available for assignment
   - Assign a team member and confirm the assignment applies to updated tickets too

4. Verify jira-sync.json contains granularity metadata on each ticket
  </verify>
  <done>
User confirms: re-running sync-jira updates existing tickets without creating duplicates. Preview correctly shows create vs update counts. Team assignment works on both created and updated tickets during incremental sync. jira-sync.json contains granularity metadata on all tickets. All SYNC requirements (01, 02, 03) are satisfied.
  </done>
</task>

</tasks>

<verification>
Phase 21 is complete when:
1. `lib/jira/sync-state.js` exists with loadSyncState, saveSyncState, diffTickets exports
2. `sync-jira.md` has 10 steps including detect_existing_sync
3. Re-running sync updates existing tickets (verified in Jira)
4. New tickets create correctly alongside existing ones
5. Team assignment works on both created and updated tickets during incremental sync
6. jira-sync.json tracks all tickets with granularity metadata
7. No duplicates created on re-run
</verification>

<success_criteria>
- SYNC-01: jira-sync.json persists ticket-to-Jira mapping with key, summary, and granularity metadata (phase/category/requirement_id)
- SYNC-02: Re-running sync calls editJiraIssue on matched tickets instead of createJiraIssue, preventing duplicates
- SYNC-03: Unmatched tickets from current planning artifacts are created as new tickets under the existing epic
</success_criteria>

<output>
After completion, create `.planning/phases/21-update-semantics-tracking/21-01-SUMMARY.md`
</output>

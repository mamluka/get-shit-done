---
phase: 18-granularity-strategy-ticket-mapping
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/jira/ticket-mapper.js
  - get-shit-done/workflows/sync-jira.md
  - commands/gsd/sync-jira.md
autonomous: true

must_haves:
  truths:
    - "User is prompted to choose ticket granularity (phase-level, category-level, requirement-level) after Jira project selection"
    - "Phase-level selection produces one ticket per phase with all requirements listed in description"
    - "Category-level selection produces one ticket per requirement category with individual requirements as checklist items"
    - "Requirement-level selection produces one ticket per REQ-ID with phase context in description"
    - "Ticket structure preview displays the mapped tickets before any Jira writes"
  artifacts:
    - path: "lib/jira/ticket-mapper.js"
      provides: "Ticket mapping logic for all three granularity levels"
      exports: ["mapTickets"]
      contains: "function mapTickets"
    - path: "get-shit-done/workflows/sync-jira.md"
      provides: "Extended workflow with granularity selection and ticket mapping steps"
      contains: "choose_granularity"
    - path: "commands/gsd/sync-jira.md"
      provides: "Updated command entry point"
  key_links:
    - from: "get-shit-done/workflows/sync-jira.md"
      to: "lib/jira/ticket-mapper.js"
      via: "inline node -e require() call in workflow step"
      pattern: "require.*ticket-mapper"
    - from: "get-shit-done/workflows/sync-jira.md"
      to: ".planning/ROADMAP.md"
      via: "ticket-mapper reads roadmap for phase data"
      pattern: "ROADMAP\\.md"
    - from: "get-shit-done/workflows/sync-jira.md"
      to: ".planning/REQUIREMENTS.md"
      via: "ticket-mapper reads requirements for category and requirement data"
      pattern: "REQUIREMENTS\\.md"
---

<objective>
Create the ticket mapping module and extend the sync-jira workflow with granularity selection and ticket structure generation.

Purpose: Enable users to choose how their planning artifacts map to Jira tickets — at phase, category, or requirement level — producing a ticket data structure ready for Phase 19's Jira API calls.

Output: `lib/jira/ticket-mapper.js` module + extended `sync-jira.md` workflow with steps 5-6 (granularity prompt + ticket mapping/preview).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/17-jira-mcp-detection-prerequisites/17-01-SUMMARY.md
@get-shit-done/workflows/sync-jira.md
@commands/gsd/sync-jira.md
@lib/notion/sync-state.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ticket-mapper module with three granularity strategies</name>
  <files>lib/jira/ticket-mapper.js</files>
  <action>
Create `lib/jira/ticket-mapper.js` that exports a `mapTickets(cwd, granularity)` function.

The module must:

1. **Read ROADMAP.md** from `.planning/ROADMAP.md` (use `resolvePlanning` pattern from sync-state.js for multi-project awareness — check for `.active-project` file, resolve nested path if present, otherwise use `.planning/` root).

2. **Read REQUIREMENTS.md** from `.planning/REQUIREMENTS.md` (same path resolution).

3. **Parse ROADMAP.md** to extract phases from the current (in-progress) milestone:
   - Find the `### Phase N: Name` headings under the in-progress milestone section (look for the section marker containing the rocket emoji or "In Progress")
   - For each phase, extract: `number`, `name`, `goal` (from `**Goal**:` line), `requirements` (from `**Requirements**:` line — comma-separated REQ-IDs like `GRAN-01, GRAN-02`), and `success_criteria` (numbered list after `**Success Criteria**`)
   - Skip phases inside `<details>` blocks (these are completed milestones)

4. **Parse REQUIREMENTS.md** to extract requirement categories and individual requirements:
   - Categories are `### Category Name` headings under `## v1.4 Requirements` (or the latest version section)
   - Requirements are `- [ ] **REQ-ID**: Description` lines under each category
   - Build a map: `{ category: string, requirements: [{ id: string, description: string }] }`

5. **Read notion-sync.json** (optional, graceful fallback) using the same multi-project path resolution as Phase 17's check_notion_sync step. Extract `doc_pages` mapping to look up Notion page URLs for ROADMAP.md. Store as `notionLinks` map for downstream Phase 19 use.

6. **Implement three mapping strategies** that return arrays of ticket objects:

   **Phase-level** (`granularity === 'phase'`):
   - One ticket per phase from the in-progress milestone
   - Each ticket: `{ type: 'phase', phaseNumber, title: "Phase {N}: {Name}", description }` where description contains the phase goal followed by a markdown list of all requirements (REQ-ID: description) assigned to that phase, then success criteria
   - Include `notionPageId` if available from notion-sync.json for the ROADMAP.md file

   **Category-level** (`granularity === 'category'`):
   - One ticket per requirement category (e.g., "Setup & Detection", "Granularity & Mapping")
   - Each ticket: `{ type: 'category', category, title: "{Category Name}", description }` where description lists which phases the category spans, and includes a checklist of requirements: `- [ ] REQ-ID: description`
   - Only include categories that have requirements mapped to phases in the current milestone

   **Requirement-level** (`granularity === 'requirement'`):
   - One ticket per individual requirement (REQ-ID)
   - Each ticket: `{ type: 'requirement', requirementId, title: "{REQ-ID}: {short description}", description }` where description includes which phase implements this requirement, the phase goal for context, and the requirement's full description
   - Include `notionPageId` if available

7. **Return value**: `{ granularity, milestone, ticketCount, tickets: [...] }` — a plain object ready for serialization to JSON.

Follow existing codebase conventions:
- CommonJS `require()` / `module.exports`
- Zero external dependencies (Node.js built-ins only: `fs`, `path`)
- Synchronous file operations (matching existing lib/notion/ pattern)
- JSDoc comments on all exported functions
- camelCase for functions, snake_case for JSON output keys
- Graceful fallback if files missing (return `{ error: '...' }` not throw)
  </action>
  <verify>
Run: `node -e "const m = require('./lib/jira/ticket-mapper.js'); console.log(typeof m.mapTickets)"` should output `function`.

Run: `node -e "const m = require('./lib/jira/ticket-mapper.js'); const r = m.mapTickets(process.cwd(), 'phase'); console.log(JSON.stringify(r, null, 2))"` should output a JSON object with `granularity: 'phase'`, `tickets` array, and `ticket_count` number.

Repeat for `'category'` and `'requirement'` granularity values — each should return a valid ticket array with different structure.
  </verify>
  <done>
`lib/jira/ticket-mapper.js` exists, exports `mapTickets`, and produces correct ticket structures for all three granularity levels when run against this project's `.planning/ROADMAP.md` and `.planning/REQUIREMENTS.md`.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend sync-jira workflow with granularity selection and ticket preview steps</name>
  <files>
    get-shit-done/workflows/sync-jira.md
    commands/gsd/sync-jira.md
  </files>
  <action>
**Extend `get-shit-done/workflows/sync-jira.md`** by adding two new steps after the existing `save_jira_config` step (step 4):

**Step 5: `choose_granularity`**

After step 4 (save_jira_config), add a new step that:

1. Displays a granularity selection prompt using `AskUserQuestion`:

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 TICKET GRANULARITY
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

How should planning artifacts map to Jira tickets?

1. Phase-level     — One ticket per phase (fewest tickets, broadest scope)
2. Category-level  — One ticket per requirement category (grouped by theme)
3. Requirement-level — One ticket per requirement (most granular)

Select granularity (1, 2, or 3):
```

2. Validates the selection is 1, 2, or 3
3. Maps the selection to the granularity string: `1` → `phase`, `2` → `category`, `3` → `requirement`
4. Saves the selection to config using: `node ~/.claude/get-shit-done/bin/gsd-tools.js config-set jira.granularity "{granularity}"`

**Step 6: `map_tickets`**

After step 5, add a step that:

1. Calls the ticket-mapper module to generate the ticket structure:

```bash
TICKETS=$(node -e '
var mapper = require("./lib/jira/ticket-mapper.js");
var result = mapper.mapTickets(process.cwd(), "{granularity}");
console.log(JSON.stringify(result));
')
```

2. Parses the result and displays a preview:

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
 TICKET PREVIEW ({granularity}-level)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Milestone: {milestone}
Tickets: {ticket_count}

{For each ticket:}
  [{N}] {ticket.title}
      {first 100 chars of description}...
```

3. Displays:
```
✓ Ticket mapping complete. {ticket_count} tickets ready for Jira sync.
  Granularity: {granularity}-level
  Run /gsd:sync-jira again after Phase 19 is implemented to create tickets in Jira.
```

This step does NOT create tickets in Jira — that is Phase 19's responsibility. This step validates the mapping is correct and shows the user what will be created.

**Update `commands/gsd/sync-jira.md`** — no changes needed to allowed-tools since no new MCP tools are used. The command file already has the correct tools listed. Only update if the description needs adjustment to reflect the extended workflow.

**Important:** Preserve all existing steps 1-4 exactly as they are. Only APPEND new steps 5-6 after the closing `</step>` tag of step 4. Match the existing markdown workflow formatting precisely (use `<step name="...">` XML tags, bash code blocks, conditional display blocks).
  </action>
  <verify>
Read `get-shit-done/workflows/sync-jira.md` and verify:
1. Steps 1-4 are unchanged from Phase 17
2. Step 5 (`choose_granularity`) exists with AskUserQuestion prompt showing three options
3. Step 6 (`map_tickets`) exists with ticket-mapper require() call and preview display
4. All step names are unique and follow existing naming convention

Read `commands/gsd/sync-jira.md` and verify the command entry point still references the workflow correctly.
  </verify>
  <done>
The sync-jira workflow has 6 steps (4 from Phase 17 + 2 new). Step 5 prompts for granularity selection with three options. Step 6 generates and previews the ticket structure using ticket-mapper.js. Existing steps 1-4 remain unmodified.
  </done>
</task>

</tasks>

<verification>
1. `lib/jira/ticket-mapper.js` exists and exports `mapTickets`
2. `mapTickets(cwd, 'phase')` returns ticket objects with one per phase
3. `mapTickets(cwd, 'category')` returns ticket objects with one per requirement category
4. `mapTickets(cwd, 'requirement')` returns ticket objects with one per REQ-ID
5. `get-shit-done/workflows/sync-jira.md` has 6 steps total
6. Step 5 presents three granularity options via AskUserQuestion
7. Step 6 calls ticket-mapper and displays preview
8. Steps 1-4 are preserved exactly from Phase 17
</verification>

<success_criteria>
- All four GRAN requirements (01-04) are addressed: GRAN-01 by step 5, GRAN-02/03/04 by ticket-mapper module
- Running `node -e "require('./lib/jira/ticket-mapper.js').mapTickets(process.cwd(), 'phase')"` produces valid phase-level tickets
- Running `node -e "require('./lib/jira/ticket-mapper.js').mapTickets(process.cwd(), 'category')"` produces valid category-level tickets
- Running `node -e "require('./lib/jira/ticket-mapper.js').mapTickets(process.cwd(), 'requirement')"` produces valid requirement-level tickets
- Workflow is ready for Phase 19 to add Jira API creation steps after step 6
</success_criteria>

<output>
After completion, create `.planning/phases/18-granularity-strategy-ticket-mapping/18-01-SUMMARY.md`
</output>

---
phase: 09-image-handling
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - lib/notion/converter.js
  - lib/notion/sync-orchestrator.js
  - lib/notion/sync-state.js
  - bin/notion-sync.js
autonomous: true

must_haves:
  truths:
    - "External image URLs (https://) in markdown render as image blocks in Notion pages"
    - "Local image files referenced in markdown upload to Notion and display correctly"
    - "Image block IDs are tracked in notion-sync.json to prevent duplicate uploads"
    - "Image references update correctly when pages are re-synced"
    - "Dry-run mode shows what images would be uploaded without calling the API"
    - "Failed image uploads produce warnings but do not abort page sync"
  artifacts:
    - path: "lib/notion/converter.js"
      provides: "Image processing step integrated into conversion pipeline"
      contains: "processLocalImages"
    - path: "lib/notion/sync-orchestrator.js"
      provides: "Image upload coordination during sync, state persistence for uploads"
      contains: "image_uploads"
    - path: "lib/notion/sync-state.js"
      provides: "Image upload state accessors (getImageUpload, setImageUpload)"
      exports: ["getImageUpload", "setImageUpload"]
    - path: "bin/notion-sync.js"
      provides: "Image upload progress in CLI output"
      contains: "image"
  key_links:
    - from: "lib/notion/sync-orchestrator.js"
      to: "lib/notion/image-uploader.js"
      via: "processLocalImages call before page create/update"
      pattern: "processLocalImages"
    - from: "lib/notion/converter.js"
      to: "lib/notion/image-uploader.js"
      via: "injectImageBlocks call after Martian conversion"
      pattern: "injectImageBlocks"
    - from: "lib/notion/sync-state.js"
      to: "notion-sync.json"
      via: "image_uploads field in project state"
      pattern: "image_uploads"
---

<objective>
Integrate the image uploader module into the existing converter pipeline and sync orchestrator. Wire image detection and upload into the sync flow so that local images are uploaded just-in-time before page creation, and image blocks appear correctly in Notion.

Purpose: Complete IMG-01, IMG-02, IMG-03 by connecting Plan 01's image uploader to the existing Phases 7-8 infrastructure.

Output: Working end-to-end image handling in the sync pipeline.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/09-image-handling/09-RESEARCH.md
@.planning/phases/09-image-handling/09-01-SUMMARY.md
@.planning/phases/07-markdown-to-notion-conversion/07-03-SUMMARY.md
@.planning/phases/08-page-hierarchy-incremental-sync/08-02-SUMMARY.md

@lib/notion/converter.js
@lib/notion/sync-orchestrator.js
@lib/notion/sync-state.js
@lib/notion/image-uploader.js
@bin/notion-sync.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend sync-state.js and integrate images into converter + sync orchestrator</name>
  <files>lib/notion/sync-state.js, lib/notion/converter.js, lib/notion/sync-orchestrator.js</files>
  <action>
**1. Extend sync-state.js with image upload accessors:**

Add two new functions:

```javascript
function getImageUpload(state, projectSlug, hash) {
  // Returns image_uploads[hash] object or null
  // { file_upload_id, local_path, uploaded_at, size_bytes, mime_type }
}

function setImageUpload(state, projectSlug, hash, uploadInfo) {
  // Creates image_uploads field if missing
  // Stores { file_upload_id, local_path, uploaded_at, size_bytes, mime_type }
}
```

Add to module.exports: `getImageUpload`, `setImageUpload`.

Ensure `initSyncState` and `setProjectState` default schemas include `image_uploads: {}` alongside existing `doc_pages`, `phase_pages`, etc.

**2. Integrate image processing into converter.js:**

Modify `convertMarkdown(markdown, options)`:
- After Step 1 (preprocessing) and before Step 2 (Martian), add an image marker injection step
- Accept optional `imageUploadMap` in options — a Map of `originalMarkdownSyntax -> uploadId`
- If `imageUploadMap` provided, replace each local image reference with `[[IMAGE_UPLOAD:uploadId:altText]]` marker
- After Step 6 (chunking), call `injectImageBlocks()` from image-uploader.js on each chunk to replace marker paragraphs with actual image blocks
- This keeps Martian working (it sees no local paths, no markers in block conversion — markers pass through as text, then get post-processed)

Update the function signature:
```javascript
function convertMarkdown(markdown, options = {}) {
  // options.imageUploadMap: Map<string, { uploadId, altText }> (optional)
```

Import `injectImageBlocks` from `./image-uploader.js`.

The flow becomes:
1. Preprocess custom tags (existing)
2. **NEW**: Replace local image paths with markers (if imageUploadMap provided)
3. Martian conversion (existing) — sees markers as plain text
4. Text splitting (existing)
5. Flatten nesting (existing)
6. Convert toggles (existing)
7. Chunk blocks (existing)
8. **NEW**: Inject image blocks (replace marker paragraphs with image blocks in each chunk)

**3. Integrate image upload into sync-orchestrator.js:**

In `syncProject()`, within the file processing loop (where `item.type === 'file'`), BEFORE calling `convertFile`:

a. Read the markdown file content
b. Call `extractLocalImages(markdown, filePath)` to find local image references
c. For each local image:
   - Validate file (skip with warning if invalid)
   - Hash file content
   - Check `getImageUpload(syncState, projectSlug, hash)` for existing upload
   - If found, reuse file_upload_id
   - If not found AND not dry-run: upload via `processLocalImages`, save via `setImageUpload`, persist state with `saveSyncState`
   - If dry-run: log "Would upload: filename (size)"
d. Build `imageUploadMap` from results
e. Pass `imageUploadMap` to `convertFile` (which passes to `convertMarkdown`)

Modify `convertFile(filePath, options)` to accept and pass `imageUploadMap` through to `convertMarkdown`.

Important: Upload images JUST BEFORE page creation (within the same file's processing), not all upfront. This respects the 1-hour upload expiry window.

Error handling: If any image upload fails, log warning, skip that image (it becomes a text paragraph via Martian's strictImageUrls=false), and continue with page sync. Never abort page sync due to image failure.

State persistence: After each successful image upload, call `saveSyncState(cwd, syncState)` immediately (atomic per-upload, matching Phase 8 per-file pattern for resume-on-error).

Commit: `feat(09-02): integrate image handling into converter and sync pipeline`
  </action>
  <verify>
1. `node -e "const ss = require('./lib/notion/sync-state.js'); console.log(typeof ss.getImageUpload, typeof ss.setImageUpload)"` — both are 'function'
2. `node -e "const c = require('./lib/notion/converter.js'); console.log(typeof c.convertMarkdown)"` — loads without error
3. `node -e "const so = require('./lib/notion/sync-orchestrator.js'); console.log(typeof so.syncProject)"` — loads without error
4. `node --test test/image-uploader.test.js` — existing tests still pass (no regressions)
5. `node bin/notion-sync.js convert .planning/ROADMAP.md --dry-run` — still works (backward compatible)
  </verify>
  <done>Image processing is wired into the conversion pipeline and sync orchestrator. sync-state.js exposes image upload tracking. converter.js accepts imageUploadMap and injects image blocks. sync-orchestrator.js uploads images just-in-time before page creation with per-upload state persistence.</done>
</task>

<task type="auto">
  <name>Task 2: Add image status to CLI output and update sync summary</name>
  <files>bin/notion-sync.js</files>
  <action>
Extend the CLI `sync` subcommand in `bin/notion-sync.js` to display image upload activity:

**1. Update progress callback display:**

The sync orchestrator's `onProgress` callback already receives events. Extend the handler to show image-related information when present:

- Add image upload counting to the progress output
- Show image upload stats in the completion summary line:
  ```
  Sync complete: 66 files (60 new, 4 changed, 2 unchanged), 3 images uploaded (1 cached)
  ```

**2. Dry-run image reporting:**

In dry-run mode, show image upload preview:
```
[DRY RUN] Would upload 3 images:
  architecture.png (125 KB)
  flow-diagram.png (89 KB)
  logo.svg (12 KB)
```

To support this, the sync orchestrator needs to return image stats in its results. Extend `syncProject` return value to include:
```javascript
{
  ...existingFields,
  imagesUploaded: 3,
  imagesCached: 1,
  imagesFailed: 0,
  imageDetails: [{ file, size, status: 'uploaded'|'cached'|'failed'|'would_upload' }]
}
```

Add this to the sync-orchestrator results tracking (initialized at top of syncProject, populated during image processing).

**3. Help text update:**

No changes needed to help text — `sync` command already shows all relevant options. The image handling is transparent (happens automatically during sync).

Commit: `feat(09-02): add image upload status to CLI sync output`
  </action>
  <verify>
1. `node bin/notion-sync.js sync --help` — shows sync usage (no errors)
2. `node bin/notion-sync.js sync --dry-run` — dry-run completes without errors, shows file list (images shown if any local images exist in .planning/)
3. All modules load: `node -e "require('./lib/notion/converter.js'); require('./lib/notion/sync-orchestrator.js'); require('./lib/notion/sync-state.js'); console.log('all loaded')"` — prints "all loaded"
  </verify>
  <done>CLI sync output includes image upload counts and dry-run image preview. Sync results include image statistics for reporting.</done>
</task>

</tasks>

<verification>
1. **Module loading (no regressions):**
   - `node -e "require('./lib/notion/converter.js'); require('./lib/notion/sync-orchestrator.js'); require('./lib/notion/sync-state.js'); require('./lib/notion/image-uploader.js'); console.log('OK')"` — prints "OK"

2. **Existing tests pass:**
   - `node --test test/image-uploader.test.js` — all Plan 01 tests still pass

3. **sync-state schema:**
   - `node -e "const s = require('./lib/notion/sync-state.js'); const state = s.initSyncState('/tmp/test-img'); console.log(JSON.stringify(state))"` — shows version, workspace_page_id, projects fields

4. **Converter backward compatibility:**
   - `node bin/notion-sync.js convert .planning/ROADMAP.md --dry-run` — works with no imageUploadMap (no image processing)

5. **CLI dry-run:**
   - `node bin/notion-sync.js sync --dry-run` — shows file list without errors

6. **Image uploader integration:**
   - `node -e "const iu = require('./lib/notion/image-uploader.js'); console.log(iu.extractLocalImages('![test](./img.png)', '/foo/bar.md'))"` — returns extraction result showing the module is correctly loaded by converter.js
</verification>

<success_criteria>
- converter.js accepts imageUploadMap and replaces local image markers with Notion image blocks
- sync-orchestrator.js uploads local images just-in-time before page creation (respects 1-hour expiry)
- sync-state.js tracks image uploads via getImageUpload/setImageUpload with hash-based keys
- Image upload state persists atomically after each upload (resume-on-error)
- Failed image uploads produce warnings, never abort page sync
- CLI shows image upload progress and summary counts
- Dry-run mode reports images that would be uploaded
- External URLs pass through unchanged (Martian handles them — no regression)
- All existing Phase 7-8 functionality preserved (backward compatible)
</success_criteria>

<output>
After completion, create `.planning/phases/09-image-handling/09-02-SUMMARY.md`
</output>

---
phase: 02-git-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - "get-shit-done/bin/gsd-tools.js"
autonomous: true
must_haves:
  truths:
    - "sanitizeForGit() converts any user input to a git-safe slug (lowercase, alphanumeric + hyphens only, no leading/trailing hyphens)"
    - "sanitizeForGit() rejects empty input and input that reduces to empty after sanitization"
    - "sanitizeForGit() handles git-check-ref-format edge cases: no double dots, no .lock suffix, no leading dot"
    - "Creating a new project via createProjectInternal() also creates and switches to a project/{slug} git branch"
    - "If the branch already exists during project creation, an error is returned with a helpful message"
    - "Switching projects via switchProjectInternal() also switches to the project/{slug} git branch"
    - "Branch switching checks for uncommitted changes and errors if working directory is dirty"
    - "getCurrentBranch() returns the current branch name or null for detached HEAD"
    - "listProjectBranches() returns all branches matching project/* pattern"
  artifacts:
    - path: "get-shit-done/bin/gsd-tools.js"
      provides: "sanitizeForGit, createAndSwitchBranch, getCurrentBranch, listProjectBranches, switchToProjectBranch functions"
      contains: "sanitizeForGit"
  key_links:
    - from: "createProjectInternal()"
      to: "createAndSwitchBranch()"
      via: "Called after folder structure creation"
      pattern: "createAndSwitchBranch"
    - from: "switchProjectInternal()"
      to: "switchToProjectBranch()"
      via: "Called after updating .active-project"
      pattern: "switchToProjectBranch"
    - from: "sanitizeForGit()"
      to: "generateSlugInternal()"
      via: "Calls generateSlugInternal first, then applies git-specific rules"
      pattern: "generateSlugInternal"
    - from: "createAndSwitchBranch()"
      to: "execGit()"
      via: "Git checkout -b for atomic branch creation"
      pattern: "execGit.*checkout.*-b"
---

<objective>
Add git branch operations to the project lifecycle: sanitize names for git safety, create project branches during project creation, and switch git branches during project switching.

Purpose: This implements GIT-01 (branch-per-project), GIT-03 (name sanitization), and Success Criteria #1, #3, #4 from the Phase 2 roadmap. Projects get isolated git branches so work on different projects doesn't mix in version history.

Output: gsd-tools.js with git branch helper functions integrated into existing project create/switch flows.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<constraints>
CRITICAL: The .claude/ folder is the INSTALLED framework (local to each user). It is NOT part of the project codebase and must NEVER be modified, committed, or referenced as a target file. All source code changes go to the ROOT get-shit-done/ folder. The mapping is:
- Source code: get-shit-done/bin/gsd-tools.js (MODIFY THIS)
- Installed copy: .claude/get-shit-done/bin/gsd-tools.js (NEVER TOUCH)
- Source workflows: get-shit-done/workflows/*.md (MODIFY THIS)
- Installed workflows: .claude/get-shit-done/workflows/*.md (NEVER TOUCH)
- Source commands: commands/gsd/*.md (MODIFY THIS)
- Installed commands: .claude/commands/gsd/*.md (NEVER TOUCH)
</constraints>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-git-integration/02-RESEARCH.md
@get-shit-done/bin/gsd-tools.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add git helper functions (sanitizeForGit, branch operations)</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Add the following functions to gsd-tools.js, placing them near the existing `execGit()` helper (around line 222) since they are git-related utilities.

**1. sanitizeForGit(input)**

Extends the existing `generateSlugInternal()` slug logic with git-check-ref-format safety rules. This function is used by ALL git operations (branches, tags) to ensure names are safe.

```javascript
function sanitizeForGit(input) {
  if (!input || typeof input !== 'string') {
    throw new Error('Input required for git name sanitization');
  }

  // Start with standard slug generation (matches existing generateSlugInternal logic)
  let sanitized = input
    .toLowerCase()
    .trim()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');

  // Git-specific rules per git-check-ref-format:
  // Remove leading dots
  if (sanitized.startsWith('.')) {
    sanitized = sanitized.replace(/^\.+/, '');
  }
  // Replace double dots with single hyphen
  sanitized = sanitized.replace(/\.\./g, '-');
  // Remove .lock suffix
  if (sanitized.endsWith('.lock')) {
    sanitized = sanitized.slice(0, -5);
  }
  // Clean up any resulting leading/trailing hyphens
  sanitized = sanitized.replace(/^-+|-+$/g, '');
  // Collapse multiple hyphens
  sanitized = sanitized.replace(/-{2,}/g, '-');

  if (sanitized.length === 0) {
    throw new Error('Sanitized name is empty after applying git safety rules');
  }

  // Final validation: must be lowercase alphanumeric with hyphens, no leading/trailing hyphens
  if (!/^[a-z0-9]([a-z0-9-]*[a-z0-9])?$/.test(sanitized)) {
    throw new Error(`Sanitized name "${sanitized}" failed git safety validation`);
  }

  return sanitized;
}
```

**2. getCurrentBranch(cwd)**

Returns current branch name or null if in detached HEAD state.

```javascript
function getCurrentBranch(cwd) {
  const result = execGit(cwd, ['symbolic-ref', '--short', 'HEAD']);
  if (result.exitCode !== 0) {
    return null; // Detached HEAD or other error
  }
  return result.stdout.trim();
}
```

**3. listProjectBranches(cwd)**

Returns array of all `project/*` branch names.

```javascript
function listProjectBranches(cwd) {
  const result = execGit(cwd, ['branch', '--list', 'project/*']);
  if (result.exitCode !== 0) {
    return [];
  }
  return result.stdout
    .split('\n')
    .map(line => line.replace(/^\*?\s+/, '').trim())
    .filter(Boolean);
}
```

**4. createAndSwitchBranch(cwd, projectSlug)**

Creates a new project branch and switches to it. Used during project creation.

```javascript
function createAndSwitchBranch(cwd, projectSlug) {
  const safeName = sanitizeForGit(projectSlug);
  const branchName = `project/${safeName}`;

  // Check if branch already exists
  const checkResult = execGit(cwd, ['rev-parse', '--verify', branchName]);
  if (checkResult.exitCode === 0) {
    return { exitCode: 1, error: `Branch ${branchName} already exists. Use project switch instead.` };
  }

  // Create and switch atomically
  const result = execGit(cwd, ['checkout', '-b', branchName]);
  if (result.exitCode !== 0) {
    return { exitCode: result.exitCode, error: `Failed to create branch: ${result.stderr}` };
  }

  return { exitCode: 0, branch: branchName, created: true };
}
```

**5. switchToProjectBranch(cwd, projectSlug)**

Switches to an existing project branch. Checks for uncommitted changes first.

```javascript
function switchToProjectBranch(cwd, projectSlug) {
  const safeName = sanitizeForGit(projectSlug);
  const branchName = `project/${safeName}`;

  // Check for uncommitted changes
  const statusResult = execGit(cwd, ['status', '--porcelain']);
  if (statusResult.exitCode === 0 && statusResult.stdout.trim().length > 0) {
    return { exitCode: 1, error: 'Uncommitted changes detected. Commit or stash before switching projects.' };
  }

  // Check branch exists
  const checkResult = execGit(cwd, ['rev-parse', '--verify', branchName]);
  if (checkResult.exitCode !== 0) {
    return { exitCode: 1, error: `Branch ${branchName} does not exist.` };
  }

  // Switch branch
  const result = execGit(cwd, ['checkout', branchName]);
  if (result.exitCode !== 0) {
    return { exitCode: result.exitCode, error: `Failed to switch to branch: ${result.stderr}` };
  }

  return { exitCode: 0, branch: branchName, switched: true };
}
```

IMPORTANT: These are pure helper functions. They do NOT call `error()` or `output()` directly -- they return result objects so callers can decide how to handle failures (some callers may want to continue despite branch operation failures, e.g., if not in a git repo).
  </action>
  <verify>
Verify all five functions exist:
```bash
grep -n "function sanitizeForGit\|function getCurrentBranch\|function listProjectBranches\|function createAndSwitchBranch\|function switchToProjectBranch" get-shit-done/bin/gsd-tools.js
```
Should show 5 matches.

Run the existing test suite to confirm no regressions:
```bash
node --test get-shit-done/bin/gsd-tools.test.js
```
  </verify>
  <done>Five git helper functions exist in gsd-tools.js: sanitizeForGit(), getCurrentBranch(), listProjectBranches(), createAndSwitchBranch(), switchToProjectBranch(). All return structured result objects. Existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate branch operations into project create/switch flows</name>
  <files>get-shit-done/bin/gsd-tools.js</files>
  <action>
Modify the existing `createProjectInternal()` and `switchProjectInternal()` functions (created by Phase 1, Plan 02) to include git branch operations. Also update init commands to include branch status.

NOTE: These functions are created by Phase 1. If Phase 1 has not been executed yet, these functions won't exist. In that case, create the git integration points as standalone functions that can be called from the project lifecycle, and add TODO comments marking where they should be wired in once Phase 1 completes. The approach below assumes Phase 1 is complete.

**1. Update createProjectInternal():**

After the folder structure creation (fs.mkdirSync calls) and before the return statement, add:

```javascript
// GIT-01: Create and switch to project branch
const branchResult = createAndSwitchBranch(cwd, slug);
// Branch creation is best-effort: project creation succeeds even if not in a git repo
const gitBranch = branchResult.exitCode === 0 ? branchResult.branch : null;
const gitError = branchResult.exitCode !== 0 ? branchResult.error : null;
```

Include `gitBranch` and `gitError` in the return object:
```javascript
return {
  slug,
  friendlyName,
  description,
  projectPath,
  created: true,
  git_branch: gitBranch,        // null if git operation failed
  git_error: gitError,          // null if git operation succeeded
};
```

**2. Update switchProjectInternal():**

After updating `.active-project` file and before the return statement, add:

```javascript
// GIT: Switch to project's git branch
const branchResult = switchToProjectBranch(cwd, projectSlug);
const gitBranch = branchResult.exitCode === 0 ? branchResult.branch : null;
const gitError = branchResult.exitCode !== 0 ? branchResult.error : null;
```

Include in return object:
```javascript
return {
  switched: true,
  project: projectSlug,
  git_branch: gitBranch,
  git_error: gitError,
};
```

**3. Update all init commands to include branch context:**

In every `cmdInit*` function's output object, add current branch information so the PM always knows which branch they're on (per Success Criteria #4):

```javascript
// Add to the result object of each init command:
current_branch: getCurrentBranch(cwd),
on_project_branch: getCurrentBranch(cwd)?.startsWith('project/') || false,
project_branches: listProjectBranches(cwd),
```

Update these init functions:
- `cmdInitPlanPhase`
- `cmdInitExecutePhase`
- `cmdInitNewProject`
- `cmdInitNewMilestone`
- `cmdInitMilestoneOp`
- `cmdInitQuick`
- `cmdInitResume`
- `cmdInitVerifyWork`
- `cmdInitPhaseOp`
- `cmdInitTodos`
- `cmdInitMapCodebase`
- `cmdInitProgress`

For each, add the three fields above to their result objects. Find each function's `output()` call and add the fields to the object being output.

CRITICAL: `getCurrentBranch()` and `listProjectBranches()` both use `execGit()` which handles errors gracefully (returns exitCode + empty strings on failure). So these calls are safe even if not in a git repo -- getCurrentBranch returns null, listProjectBranches returns [].

**4. Add `git` subcommand to the main dispatcher:**

Add a new case in the switch statement for git-specific operations that workflows can call directly:

```javascript
case 'git': {
  const subcommand = args[1];
  if (subcommand === 'current-branch') {
    output({ branch: getCurrentBranch(cwd) }, raw);
  } else if (subcommand === 'project-branches') {
    output({ branches: listProjectBranches(cwd) }, raw);
  } else if (subcommand === 'sanitize') {
    try {
      const sanitized = sanitizeForGit(args[2]);
      output({ sanitized, original: args[2] }, raw);
    } catch (err) {
      output({ error: err.message, original: args[2] }, raw);
    }
  } else {
    error('Unknown git subcommand. Available: current-branch, project-branches, sanitize');
  }
  break;
}
```

This exposes the git helpers to workflows that need branch information.
  </action>
  <verify>
Verify the git subcommand works:
```bash
node ./get-shit-done/bin/gsd-tools.js git current-branch --raw
node ./get-shit-done/bin/gsd-tools.js git sanitize "My Cool Project!" --raw
node ./get-shit-done/bin/gsd-tools.js git project-branches --raw
```

Verify init commands include branch fields:
```bash
node ./get-shit-done/bin/gsd-tools.js init plan-phase 1 --raw 2>/dev/null | grep -o "current_branch"
```

Run existing test suite:
```bash
node --test get-shit-done/bin/gsd-tools.test.js
```
  </verify>
  <done>createProjectInternal() creates a git branch during project creation. switchProjectInternal() switches git branches during project switching. All init commands include current_branch, on_project_branch, and project_branches fields. The `git` CLI subcommand exposes branch operations to workflows. Existing tests pass. Branch operations are best-effort (project creation/switching succeeds even without git).</done>
</task>

</tasks>

<verification>
1. `node ./get-shit-done/bin/gsd-tools.js git sanitize "My Cool Project!" --raw` returns `{"sanitized":"my-cool-project","original":"My Cool Project!"}`
2. `node ./get-shit-done/bin/gsd-tools.js git sanitize "test..name.lock" --raw` returns a sanitized name with git-unsafe chars removed
3. `node ./get-shit-done/bin/gsd-tools.js git current-branch --raw` returns current branch name
4. `node ./get-shit-done/bin/gsd-tools.js git project-branches --raw` returns array of project branches
5. `grep -c "function sanitizeForGit" get-shit-done/bin/gsd-tools.js` returns 1
6. `grep -c "createAndSwitchBranch" get-shit-done/bin/gsd-tools.js` returns 2+ (definition + usage in createProjectInternal)
7. `grep -c "switchToProjectBranch" get-shit-done/bin/gsd-tools.js` returns 2+ (definition + usage in switchProjectInternal)
8. `node --test get-shit-done/bin/gsd-tools.test.js` passes
</verification>

<success_criteria>
- sanitizeForGit() handles spaces, special characters, uppercase, git-check-ref-format edge cases
- Creating a project creates project/{slug} branch and switches to it
- Switching a project switches to the project/{slug} branch
- Dirty working directory prevents branch switching with clear error
- Branch-already-exists during creation returns helpful error
- All init commands report current branch and project branch list
- `git` CLI subcommand available for workflow use
- Operations are best-effort: project lifecycle works even without git repo
- Existing test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-git-integration/02-01-SUMMARY.md`
</output>

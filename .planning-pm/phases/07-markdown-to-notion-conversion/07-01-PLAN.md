---
phase: 07-markdown-to-notion-conversion
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/notion/preprocessor.js
  - lib/notion/text-splitter.js
  - test/notion/preprocessor.test.js
  - test/notion/text-splitter.test.js
autonomous: true

must_haves:
  truths:
    - "Custom XML tags (<domain>, <decisions>, <specifics>, <deferred>) convert to GFM alert syntax that Martian renders as callout blocks"
    - "<details>/<summary> blocks convert to blockquote structure preserving summary as heading and content as body"
    - "Unsupported HTML elements (raw HTML, footnotes, math blocks) wrap in fenced code blocks as fallback"
    - "Rich text exceeding 2000 characters splits at sentence boundaries without truncation"
    - "Horizontal rules (---) pass through unchanged for Martian to convert to divider blocks"
    - "Checkbox syntax (- [x], - [ ]) passes through unchanged for Martian to convert to to_do blocks"
  artifacts:
    - path: "lib/notion/preprocessor.js"
      provides: "Markdown preprocessing for GSD custom patterns"
      exports: ["preprocessMarkdown"]
    - path: "lib/notion/text-splitter.js"
      provides: "Sentence-boundary text splitting for Notion 2000-char limit"
      exports: ["splitRichText", "splitTextAtSentences"]
    - path: "test/notion/preprocessor.test.js"
      provides: "Test coverage for preprocessor"
      contains: "preprocessMarkdown"
    - path: "test/notion/text-splitter.test.js"
      provides: "Test coverage for text-splitter"
      contains: "splitRichText"
  key_links:
    - from: "lib/notion/preprocessor.js"
      to: "@tryfabric/martian"
      via: "Output feeds into markdownToBlocks()"
      pattern: "GFM alert syntax.*\\[!NOTE\\]"
    - from: "lib/notion/text-splitter.js"
      to: "Notion API rich_text"
      via: "Processes rich_text arrays from Martian output"
      pattern: "Intl\\.Segmenter"
---

<objective>
Create the markdown preprocessor and text splitter modules for the Notion conversion pipeline.

Purpose: The preprocessor transforms GSD-specific markdown patterns (custom XML tags, details/summary, unsupported HTML) into standard markdown that @tryfabric/martian can convert. The text splitter handles Notion's 2000-character rich text limit by splitting at sentence boundaries. Together these form the input and output stages around Martian's core conversion.

Output: Two tested utility modules (preprocessor.js, text-splitter.js) ready for the converter orchestrator in Plan 03.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-markdown-to-notion-conversion/07-RESEARCH.md
@.planning/phases/07-markdown-to-notion-conversion/07-CONTEXT.md
@.planning/phases/06-foundation-sdk-setup/06-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD preprocessor.js — custom tag, details/summary, and unsupported HTML transformation</name>
  <files>lib/notion/preprocessor.js, test/notion/preprocessor.test.js</files>
  <action>
    Create lib/notion/preprocessor.js exporting a single `preprocessMarkdown(markdown)` function that transforms GSD-specific patterns into standard markdown before Martian conversion.

    **Custom XML tag conversion (per user decision: callout blocks with labels):**
    Transform `<domain>`, `<decisions>`, `<specifics>`, `<deferred>` tags into GFM alert syntax that Martian converts to Notion callout blocks. Use these mappings:
    - `<domain>` -> `> [!NOTE]` with label "Domain" (blue callout)
    - `<decisions>` -> `> [!IMPORTANT]` with label "Decisions" (purple callout)
    - `<specifics>` -> `> [!TIP]` with label "Specifics" (green callout)
    - `<deferred>` -> `> [!CAUTION]` with label "Deferred" (red callout)

    Pattern: Match `<tag>\n...content...\n</tag>` (multiline, dotall). Extract content between tags. Prefix each line with `> ` for blockquote. Add GFM alert header as first line. IMPORTANT: Case must be UPPERCASE for GFM alerts (Martian is case-sensitive per research pitfall #6).

    **Details/summary conversion (per user decision: toggle/heading blocks):**
    Transform `<details><summary>Title</summary>content</details>` into a blockquote structure:
    ```
    > **Title**
    >
    > content lines prefixed with >
    ```
    Martian will convert this to a quote block. Plan 03's post-processor will convert quote to toggle block. Handle nested content (paragraphs, lists, code blocks inside details).

    **Unsupported HTML fallback (per user decision: code block, never silently dropped):**
    After custom tag and details/summary processing, scan for remaining HTML tags (not standard markdown-compatible ones like `<br>`, `<img>`, `<a>`). Wrap unsupported HTML blocks in fenced code blocks with `html` language hint:
    ````
    ```html
    <unsupported-tag>content</unsupported-tag>
    ```
    ````

    **Pass-through elements (Martian handles natively):**
    Do NOT transform: horizontal rules (`---`), checkboxes (`- [x]`, `- [ ]`), standard markdown headings, lists, tables, code blocks, inline formatting. These pass through to Martian unchanged.

    **TDD cycle:**
    RED: Write tests first covering:
    1. Each custom XML tag converts to correct GFM alert with uppercase type
    2. Nested content inside custom tags preserves formatting (headings, lists, code)
    3. Details/summary with simple text content
    4. Details/summary with complex nested content (lists, code blocks)
    5. Unsupported HTML wraps in code block
    6. Standard markdown passes through unchanged (headings, lists, tables, code, checkboxes, horizontal rules)
    7. Multiple custom tags in same document
    8. Empty/missing content in tags handles gracefully
    9. Tags with attributes (if any) still match

    GREEN: Implement preprocessMarkdown to pass all tests.
    REFACTOR: Clean up if needed.

    Use Node.js built-in test runner (`node --test`) to match codebase zero-dependency pattern. Do NOT install jest, mocha, or other test frameworks.
  </action>
  <verify>
    Run `node --test test/notion/preprocessor.test.js` — all tests pass.
    Manually verify: `node -e "const {preprocessMarkdown} = require('./lib/notion/preprocessor.js'); console.log(preprocessMarkdown('<domain>\\n## Test\\nContent\\n</domain>'))"` outputs GFM alert blockquote.
  </verify>
  <done>
    preprocessMarkdown() correctly transforms all 4 custom XML tags to GFM alerts with uppercase type names. Details/summary converts to blockquote. Unsupported HTML wraps in code blocks. Standard markdown passes through unchanged. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD text-splitter.js — sentence-boundary splitting for 2000-char rich text limit</name>
  <files>lib/notion/text-splitter.js, test/notion/text-splitter.test.js</files>
  <action>
    Create lib/notion/text-splitter.js exporting two functions:

    **`splitTextAtSentences(text, maxLength = 2000)`**
    Split a plain text string at sentence boundaries when it exceeds maxLength. Use `Intl.Segmenter('en', { granularity: 'sentence' })` (built-in Node 16+, zero dependencies). Returns array of strings, each under maxLength. Per research: handles abbreviations (Dr., Inc.), decimals (3.14), ellipsis correctly — do NOT hand-roll with regex.

    Edge cases:
    - Text under maxLength returns single-element array
    - Empty string returns empty array
    - Single sentence longer than maxLength: split at word boundaries as fallback (use Intl.Segmenter with granularity 'word')
    - Whitespace trimming: trim each chunk but preserve internal whitespace

    **`splitRichText(richTextArray, maxLength = 2000)`**
    Process a Notion rich_text array (from Martian output). For each rich_text object whose `text.content` exceeds maxLength, split using splitTextAtSentences and create multiple rich_text objects preserving the original annotations (bold, italic, etc.).

    Rich text object structure (from Martian/Notion API):
    ```javascript
    {
      type: 'text',
      text: { content: 'long text...', link: null },
      annotations: { bold: false, italic: false, strikethrough: false, underline: false, code: false, color: 'default' },
      plain_text: 'long text...'
    }
    ```

    When splitting, each resulting chunk gets the same `type`, `annotations`, and `link` as the original. Only `text.content` and `plain_text` change.

    **TDD cycle:**
    RED: Write tests first covering:
    1. Short text (< 2000 chars) returns unchanged
    2. Long text splits at sentence boundaries
    3. Text with abbreviations (Dr., Mrs., Inc.) doesn't split mid-abbreviation
    4. Text with decimals (3.14) doesn't split at decimal point
    5. Single sentence exceeding 2000 chars falls back to word-boundary splitting
    6. Empty input returns empty output
    7. Rich text array with mixed short/long elements processes correctly
    8. Annotations preserved across splits
    9. Multiple rich_text objects in array, only long ones split
    10. Exact 2000-char text returns unchanged (boundary condition)

    GREEN: Implement both functions to pass tests.
    REFACTOR: Clean up if needed.

    Use Node.js built-in test runner (`node --test`).
  </action>
  <verify>
    Run `node --test test/notion/text-splitter.test.js` — all tests pass.
    Manually verify: `node -e "const {splitTextAtSentences} = require('./lib/notion/text-splitter.js'); console.log(splitTextAtSentences('Hello world. This is a test.', 15))"` outputs array with split chunks.
  </verify>
  <done>
    splitTextAtSentences() splits text at sentence boundaries using Intl.Segmenter. splitRichText() processes Notion rich_text arrays, splitting long text while preserving annotations. Falls back to word-boundary splitting for single oversized sentences. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `node --test test/notion/preprocessor.test.js` — all tests green
2. `node --test test/notion/text-splitter.test.js` — all tests green
3. `node -e "require('./lib/notion/preprocessor.js')"` — loads without error
4. `node -e "require('./lib/notion/text-splitter.js')"` — loads without error
5. No external test dependencies added (uses Node.js built-in test runner)
</verification>

<success_criteria>
- preprocessor.js handles all 4 GSD custom XML tags, details/summary, and unsupported HTML
- text-splitter.js splits at sentence boundaries using Intl.Segmenter with word-boundary fallback
- Both modules export clean APIs ready for converter.js integration
- All TDD tests pass with meaningful coverage of edge cases
- Zero external dependencies added (Intl.Segmenter is built-in)
</success_criteria>

<output>
After completion, create `.planning/phases/07-markdown-to-notion-conversion/07-01-SUMMARY.md`
</output>
